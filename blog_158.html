<html xmlns="http://www.w3.org/1999/xhtml" lang="zh-cn">
<head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"></head>
<title>GDI&#x53CA;Windows&#x7684;&#x6D88;&#x606F;&#x673A;&#x5236;</title>
<body><h3>什么是GDI？</h3> <p>GDI, Graphics Device Interface</p> <p>GDI在以下位置已经被微软列为Legacy Graphics，不建议使用来开发应用程序（<a href="http://msdn.microsoft.com/zh-CN/library/windows/desktop/hh309470(v=vs.85).aspx">http://msdn.microsoft.com/zh-CN/library/windows/desktop/hh309470(v=vs.85).aspx</a>）。</p> <p>但是这里我们需要了解的是GDI的原理，比如为什么能够用它来做出透明的效果。</p> <p>（事实上这个问题的答案是LayeredWindow是怎么工作的）</p> <p>&nbsp;</p> <p>GDI就一系列的Windows API函数的集合，负责代表用户程序来进行图像图形的操作。</p> <p>&nbsp;</p> <p><strong>GDI+：</strong></p> <blockquote> <p>Windows GDI+ is a class-based API for C/C++ programmers.</p> <p>&nbsp;</p></blockquote> <hr>  <p align="left"><font color="#0080ff" size="4" face="楷体">Other topic(Windows消息机制：</font><a href="http://msdn.microsoft.com/zh-CN/library/windows/desktop/ff381405(v=vs.85).aspx"><font color="#0080ff" size="4" face="楷体">http://msdn.microsoft.com/zh-CN/library/windows/desktop/ff381405(v=vs.85).aspx</font></a><font color="#0080ff" size="4" face="楷体">)</font></p> <p align="left"><font color="#0080ff" size="4" face="楷体"></font>&nbsp;</p> <blockquote> <p align="left"><font color="#0080ff" size="4" face="楷体">To pass a message to a window, the operating system calls the window procedure registered for that window. (And now you know what the window procedure is for.)</font></p></blockquote> <p align="left"><font color="#0080ff" size="4" face="楷体">一个窗口程序，需要对外界发生的事件进行一定的响应，比如：</font></p> <ul> <li> <div align="left"><font color="#0080ff" size="4" face="楷体">用户按下了某个键</font></div> <li> <div align="left"><font color="#0080ff" size="4" face="楷体">系统的状态发生了改变，应用程序必须做相应的反馈（笔记本电池电量低）</font></div></li></ul> <p align="left"><font color="#0080ff" size="4" face="楷体">这是通过消息机制完成的。</font></p> <p align="left"><font color="#0080ff" size="4" face="楷体"></font>&nbsp;</p> <p align="left"><font color="#0080ff" size="4" face="楷体">向一个窗口发送消息，是通过调用那个窗口注册到Windows操作系统的窗口过程函数(Windows Procedure Function)来完成的。</font></p> <blockquote> <p align="left"><font color="#0080ff" size="4" face="楷体">For each thread that creates a window, the operating system creates a queue for window messages. This queue holds messages for all of the windows that are created on that thread. The queue itself is hidden from your progam. You can't manipulate the queue directly, but you can pull a message from the queue by calling the </font><a href="http://msdn.microsoft.com/zh-CN/library/windows/desktop/ms644936(v=vs.85).aspx"><strong><font color="#0080ff" size="4" face="楷体">GetMessage</font></strong></a><font color="#0080ff" size="4" face="楷体"> function.</font></p></blockquote> <p align="left"><font color="#0080ff" size="4" face="楷体">对于每一窗口，它都要接收很多消息，这些消息不能一次性的都立即得到响应，因此需要一种缓存机制，把消息缓存到queue里面，然后在窗口过程函数处理完上一个消息后，可以从队列里再取出下一条消息进行处理。</font></p> <p align="left"><font color="#0080ff" size="4" face="楷体"></font>&nbsp;</p> <p align="left"><font color="#0080ff" size="4" face="楷体">而实际上，操作系统采用了更加高效的处理办法，并不是为每个窗口过程都维护一个窗口队列，而是为创建了窗口的线程维护一个消息queue，这样做的好处是，如果一个线程创建了多个窗口的话，那么并不需要维护多个消息队列，维护一个就够了。</font></p> <p align="left"><font color="#0080ff" size="4" face="楷体">之所以这么做，还有一个重要的原因，是Windows操作系统为认为创建窗口的这个线程是要为窗口的一生去负责的。因此下面讲到的消息循环函数，也是在这个线程中的。</font></p> <blockquote> <p align="left"><font color="#0080ff" size="4" face="楷体">The </font><a href="http://msdn.microsoft.com/zh-CN/library/windows/desktop/ms644934(v=vs.85).aspx"><strong><font color="#0080ff" size="4" face="楷体">DispatchMessage</font></strong></a><font color="#0080ff" size="4" face="楷体"> function tells the operating system to call the window procedure of the window that is the target of the message. In other words, the operating system looks up the window handle in its table of windows, finds the function pointer associated with the window, and invokes the function.</font></p></blockquote> <p align="left"><font color="#0080ff" size="4" face="楷体">这样，消息队列就变成了与线程相关的一个数据结构，可以预见，这是通过类型TLS(线程局部存储)类似的手段来管理的。</font></p> <p align="left"><font color="#0080ff" size="4" face="楷体">在这个线程中，编写消息循环函数，就像是一个泵一样，它负责源源不断地把消息从queue中抽出来，再经过TranslateMessage和DispatchMessage的处理，将消息发送到它所负责维护的相应的窗口过程中去。</font></p> <hr>  <h3>我们能用GDI来做些什么？</h3> <h3>哪里有关于GDI最详细的文档？</h3> <h3>GDI的局限性有哪些？</h3> <h3>GDI有什么替代或者相关的技术吗？</h3></body>
</html>
