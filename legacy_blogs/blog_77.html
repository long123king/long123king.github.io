<html xmlns="http://www.w3.org/1999/xhtml" lang="zh-cn">
<head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"></head>
<title>Taint&#x5206;&#x6790;</title>
<body><blockquote> <p>FireEye的理论基础是<a href="http://bitblaze.cs.berkeley.edu/papers/taintcheck-full.pdf">taint分析</a>，简单的说就是对应内存有一块影子内存用于标记位，首先<font color="#9b00d3">所有的网络输入对应影子内存都是标识为tainted的</font>，接下来做的虚拟执行，<font color="#9b00d3">所有有关这一类内存的操作，以及操作结果影响到的内存，都认为是tainted的</font>来进行影子内存标识。<font color="#9b00d3">如果发现某一类指针调用的地址是tainted的</font>，那么就判断很有可能是exploit被执行了。这个理论基础主要是认为数据和代码在某种意义上是分离的，在对于XSS和SQL Injection等一类脚本问题上，这个方法可以说是非常有效，但对于其他方面，情况则更复杂一些，比如JIT之类，可能有一定的局限性。总的来说，这个方法还是有效</p> <p><a title="http://hi.baidu.com/0x557/item/912eddd108e994e7785daa18" href="http://hi.baidu.com/0x557/item/912eddd108e994e7785daa18">http://hi.baidu.com/0x557/item/912eddd108e994e7785daa18</a></p></blockquote> <p>参考：<a title="http://bitblaze.cs.berkeley.edu/papers/taintcheck-full.pdf" href="http://bitblaze.cs.berkeley.edu/papers/taintcheck-full.pdf">http://bitblaze.cs.berkeley.edu/papers/taintcheck-full.pdf</a></p> <p>&nbsp;</p> <blockquote> <p>Fusion of Static and Dynamic Analysis.Static and dynamic analysis both have advantages and disadvantages. Static analysis can give more complete results as it covers<br>different execution paths, however, it may be difficult due to the complexity of pointer<br>aliasing, the prevalence of indirect jumps, and the lack of types and other higher-level<br>abstractions in binaries. Even telling what is code and what is data statically is an undecidable problem in general. Moreover, it is particularly challenging for static analysis<br>to deal with dynamically generated code and other anti-static-analysis techniques employed in malicious code. Furthermore, certain instructions such as kernel and floating<br>point instructions may be extremely challenging to accurately model. On the other hand,<br>dynamic analysis naturally avoid many of thedifficulties that static analysis needs to<br>face, at the cost of analyzing one path at a time. Thus, we would like to combine static<br>and dynamic analysis whenever possible to have the benefits of both.</p> <p><a title="http://bitblaze.cs.berkeley.edu/papers/bitblaze_iciss08.pdf" href="http://bitblaze.cs.berkeley.edu/papers/bitblaze_iciss08.pdf">http://bitblaze.cs.berkeley.edu/papers/bitblaze_iciss08.pdf</a></p></blockquote> <p><strong>static analysis的缺点：无法检查对于间接地址的访问，无法检查动态生成的内存</strong></p> <p><strong>dynamic analysis的缺点：一次只能沿着一条路径执行</strong></p> <p><strong></strong>&nbsp;</p> <p>FPGate的做法大致如下：</p> <p>根据Relocation Table以及Export Table打到合法的间接寻址目标，然后对于间接调用和跳转，采用一种加密的方式来保存这些间接地址。</p> <blockquote> <p><font style="background-color: #ffffff" color="#000000">All indirect code entries must be reachable from relocation tables and export tables.</font></p> <p><font style="background-color: #ffffff" color="#000000">（因为这些间接地址，按道理来说，都应该是高级语言的compiler生成的）</font></p> <p><font style="background-color: #ffffff" color="#000000"></font>&nbsp;</p></blockquote> <p>这句话给我们的启示是：</p> <p><font color="#ff0000">1. FPGate并不难实现，只是在对control transfer指令动态插桩的时候，添加上对于目标合法性的判断。</font></p> <p>2. Static Analysing也可以利用这个假设，从relocation tables和export tables作为起点来搜索CFG图。</p> <p>&nbsp;</p> <p>&nbsp;</p> <p>&nbsp;</p> <p>ASLR与relocation的关系</p> <p>参考：<a title="http://en.wikipedia.org/wiki/Relocation_(computing)" href="http://en.wikipedia.org/wiki/Relocation_(computing)">http://en.wikipedia.org/wiki/Relocation_(computing)</a></p> <blockquote> <p>With 32-bit Windows operating systems it is not mandatory to provide relocation tables for EXE files, since they are the first image loaded into the virtual address space and thus will be loaded at their preferred base address.  <p>For both DLLs and for EXEs which opt into <a href="http://en.wikipedia.org/wiki/Address_Space_Layout_Randomisation">Address Space Layout Randomisation</a> - an exploit mitigation technique introduced with Windows Vista, relocation tables once again become mandatory because of the possibility that the binary may be dynamically moved before being executed, even though they are still the first thing loaded in the virtual address space.</p></blockquote> <p>在Vista之前，对于exe文件来说，relocation并不是必需的，因为exe模块通常第一个被load进内存，因此它prefer的基地址总是能够得到满足；  <p>但是在Vista之后，ASLR保护机制被添加进系统支持中，如果开启了ASLR，就不管是exe还是dll都需要relocation信息。  <p>&nbsp; <p>在Visual Studio 2012中编译的应用程序是包含relocation信息的，但是在Visual Studio 2005中编译的应用程序却不包含relocation信息。  <p>&nbsp; <p>Control Flow Integrity  <p>参考：<a title="http://users.soe.ucsc.edu/~abadi/Papers/cfi-tissec-revised.pdf" href="http://users.soe.ucsc.edu/~abadi/Papers/cfi-tissec-revised.pdf">http://users.soe.ucsc.edu/~abadi/Papers/cfi-tissec-revised.pdf</a>  <p>&nbsp; <blockquote> <p>For example, CFI can prevent the circumvention of two wellknown enforcement mechanisms,<strong> </strong></p> <p><strong><font color="#333333">Inlined Reference Monitors (IRMs)</font></strong> and <strong>Software Fault Isolation (SFI)</strong></p></blockquote> <p>&nbsp; <blockquote> <p>CFI requires that, during program execution, whenever a machine-code instruction transfers control, it targets a valid destination, as determined by a CFG created ahead of time.  <p>Since most instructions target a constant destination, this requirement can usually be discharged statically. However, for computed control-flow transfers (those whose destination<br>is determined at runtime) this requirement must be discharged with a dynamic check.</p></blockquote> <p>直接目标地址可以通过静态方法来验证，而间接目标地址就必须要通过动态方法来验证了。</p> <p>&nbsp;</p> <blockquote> <p>In particular, for these initial explanations, we rely on three new<br>machine-code instructions, with an immediate operand ID: </p> <p>1） an effect-free <strong>label ID</strong> instruction; </p> <p>2） a call instruction <strong>call ID, DST</strong> that transfers control to the code at the address<br>contained in register DST only if that code starts with label ID; </p> <p>3） and a corresponding return instruction <strong>ret ID</strong>. </p></blockquote> <blockquote> <p>&nbsp;</p> <p><strong>Computed control transfers are instrumented</strong></p></blockquote> <p>&nbsp; <p><strong></strong></p> <p>FPGate的论文中，提出了能够违反CFI的几种情况：</p> <blockquote> <p>On modern x86 platforms, attackers can use only the following four methods to violate control-flow<br>integrity in user space:</p> <p><br><font color="#9b00d3">(a) Modify instructions directly.<br>(b) Modify return addresses.<br>(c) Modify system exception handlers.<br>(d) Modify indirect call/jmp targets, including function pointers.</font></p></blockquote> <p>里面提到，前三种都有比较可靠的解决方案了：</p> <p>“写与执行权限互斥”可以有效地防止在运行期间修改代码段，这是在分页机制中实现的，保证每个内存页都不可能同时具有写与执行两种权限；</p> <p>参考：<a title="http://en.wikipedia.org/wiki/Stack-smashing_protection#GCC_Stack-Smashing_Protector_.28ProPolice.29" href="http://en.wikipedia.org/wiki/Stack-smashing_protection#GCC_Stack-Smashing_Protector_.28ProPolice.29">http://en.wikipedia.org/wiki/Stack-smashing_protection#GCC_Stack-Smashing_Protector_.28ProPolice.29</a></p> <p>GS cookie和Stack Smashing Protector等等方案可以解决利用返回地址的利用；</p> <p>Safe SEH可以解决对于excetion handler的利用；</p> <p>FPGate可以解决第四种情况。</p> <hr>  <p><strong>FPGate的核心设计是，引入了一层stub函数，在每个潜在的目标代码片段的前部。</strong></p> <p><strong>这样，当出现了间接流程转移的时候，就可以通过判断是否调用到了stub函数部分来判断目标地址的合法性。</strong></p> <p><strong></strong>&nbsp;</p> <p><strong>具体判断方法，类似于stack canary，就是在stub前面添加一个magic字段，每次间接流程转移，都会根据这个magic来判断是否合法。</strong></p> <p><strong></strong>&nbsp;</p> <p><strong>而判断目标地址合法的关键，就是relocation table/export table。</strong></p> <p><strong>但是这明显不适合那些在Vista之前开发，或者针对XP系统开发的程序（exe里面可能根本就没有relocation信息）。</strong></p> <p><strong></strong>&nbsp;</p> <p><strong></strong>&nbsp;</p> <p><strong>另外一个有启发意义的是shadow stack</strong></p> <p><strong></strong>&nbsp;</p> <p><strong>这张图更加直白地解释了CFI</strong></p> <p><a href="http://images.cnitblog.com/blog/580388/201404/211448380768270.png"><img style="background-image: none; border-right-width: 0px; padding-left: 0px; padding-right: 0px; display: block; float: none; border-top-width: 0px; border-bottom-width: 0px; margin-left: auto; border-left-width: 0px; margin-right: auto; padding-top: 0px" title="image" border="0" alt="image" src="http://images.cnitblog.com/blog/580388/201404/211448385136671.png" width="646" height="478"></a></p> <p>&nbsp;</p> <p>FPGate凭什么说它比CFI更加高级？</p> <p>&nbsp;</p> <p> <hr> 静态扫描代码的方法总结：  <blockquote> <p>In the rst phase, BitCover checks all possible code entry points to determine if they are valid. It<br>also identi es known control tables based on their special characteristics.<br>For a given address in the code section (i.e. a possible program counter (PC) value), BitCover uses the following rules to determine whether it is a valid instruction:<br><strong>1. No invalid instruction permitted</strong></p> <p><strong>2. No instruction overlaps with another<br>3. A valid instruction must lead to other valid instructions<br>4. The set of code reachable from an entry point should stop at a return, a terminating function<br>or an indirect jump to an unknown target</strong></p> <p><strong>5. All addresses' size must be valid<br>6. If an instruction contains a .reloc pointee, the pointee must be a valid immediate value or<br>offset.<br>7. All absolute addresses in code must be relocated, except special system values<br>8. IO/interrupt instructions are permitted only in specied situations<br>9. Only specied segment registers can be used in code (A terminating function is one that is not </strong></p> <p><strong>expected to return to its caller, such as exit or abort in C).</strong></p> <p><br>Due to rule (4) in section 2.1, all indirect code entries must be in reloc entries or in the export ta<br>ble. For each code entry in these tables, BitCover disassembles from it recursively. If it meets an in<br>valid instruction during the recursive exploration process, it invalidates the entry. During the pro<br>cess, BitCover needs also to propagate information about terminating functions in order to stop prop<br>erly.</p></blockquote> <p>另外一篇参考<a title="http://www-users.cselabs.umn.edu/classes/Spring-2014/csci8271/slides/03a-harden-cots.pdf" href="http://www-users.cselabs.umn.edu/classes/Spring-2014/csci8271/slides/03a-harden-cots.pdf">http://www-users.cselabs.umn.edu/classes/Spring-2014/csci8271/slides/03a-harden-cots.pdf</a></p> <p>&nbsp;</p> <h4>线性扫描</h4> <p>即假设代码块都是一块紧接着另一块的。</p> <p>例外的情况是gap, 以及代码块的地址对立。</p> <p>&nbsp;</p> <h4>深度扫描</h4> <p>深度优先，即从export table/entry point/relocation table入手，逐个深入。</p> <p>缺点，是无法到达与上述入口点不直接相通(即这些入口点没有通过直接寻址方式与其相通)的代码块。</p> <p>&nbsp;</p> <h4>线性与深度结合扫描</h4> <p>首先，线性扫描全部二进制代码，逐条进行；</p> <p>然后，检查出错指令：</p> <p>invalid opcode</p> <p>direct CF to outside this module</p> <p>direct CF to the middle of another instruction.</p> <p>&nbsp;</p> <h4>越过gap的方法</h4> <p>gap的开始位置的上一条指令，一定是CF(直接流程跳转指令，比如jmp/call/ret)</p> <p>通过一种特殊的<strong>静态分析方法ICF</strong>，来确定在gap之后的第一条有效指令</p> <p>&nbsp;</p> <p>&nbsp;</p> <p> <hr> 个人总结  <p>&nbsp;</p> <p><strong>1. 可以先通过“深度扫描”的方式，先指出直接连通的CFG图</strong></p> <p><strong>2. 尝试查找relocation table，作为Graph的入口点(需要判断是否是Graph的入口点)</strong></p> <p><strong>3. 尝试查找export table，作为Graph的入口点(需要判断是否是Graph的入口点)</strong></p> <p><strong><font color="#9b00d3">3.5 尝试查找symbol，作为Graph的入口点（需要DbgHelp.dll的支持），但是这是动态时才能拿到的信息。</font></strong></p> <p><strong>4. 扫描各个Graph之间的空隙地带，通过判断起始指令的有效性，来确认空隙地带是否是新的Graph入口点</strong></p> <p><strong></strong>&nbsp;</p> <p><strong>5. 在4中的一轮全局空隙扫描之后，再进行一轮空隙扫描。</strong></p> <p>&nbsp;</p> <p>重定位表</p> <blockquote> <p>重定位表由一个个的重定位块组成，如果重定位表存在的话，必定是至少有一个重定位块。<br>因为每个块只负责定位0x1000大小范围内的数据，因此如果要定位的数据范围比较大的话，<br>就会有多个重定位块存在。  <p>每个块的首部是如下定义：<br>typedef struct _IMAGE_BASE_RELOCATION {<br>DWORD&nbsp; VirtualAddress;<br>DWORD&nbsp; SizeOfBlock;<br>} IMAGE_BASE_RELOCATION;  <p>把内存中需要重定位的数据按页的大小0x1000分为若干个块，而这个VirtualAddress就是每个块的起始RVA.只知道块的RVA当然还不行，我们要知道每一个需要重定位数据的具体地址。</p></blockquote> <p>参考：<a title="http://www.mouseos.com/windows/PE_image6.html" href="http://www.mouseos.com/windows/PE_image6.html">http://www.mouseos.com/windows/PE_image6.html</a></p> <p>&nbsp;</p> <blockquote> <p>Relocation mechanism of the PE format relates to several addresses. We de ne them as the following:<br>1.<strong> Reloc item:</strong> exists in the .reloc table. Each item is 2-bytes long, where the highest 4 bits describe the relocation type and the lower 12 bits are used to compute the reloc slot ;<br>2. <strong>Reloc slot:</strong> address of the memory which contains a reloc entry, must be 4-bytes long in 32bit systems;【哪个位置的内存中包含了需要更新的位置/Address】<br>3. <strong>Reloc entry:</strong> content which needs to be updated when loaded by the system loader, it is usually the address of functions or global variables etc.</p> <p><br>For example, in Fig.1 (a), a reloc item existed in the relocation table (i.e. the .reloc section) is 0x31A4, where, its type is 3 and means this reloc item is a normal one. </p> <p>The reloc slot represented by this item is 0x4011A4, it is computed through 0x400000 + 0x1000+0x1A4, </p> <p>where, 0x400000 is the image base of the PE file, </p> <p>&nbsp;</p> <p>0x1000 is the relocatable page's Relative Virtual Address (RVA) and it is stored in the relocation table too, </p> <p>&nbsp;</p> <p>0x14A is the lower 12 bits of the reloc item and it means the reloc slot's o set in the relocatable page.</p></blockquote> <blockquote> <p>The actual content stored in this reloc slot is <strong>0x401120【怎么知道的】</strong>, i.e. the reloc entry, it is the address of a function fp1, which will be updated when loading.</p></blockquote> <p>怎么知道的，0x00401120就保存在PE映像文件的对应0x4011A4处。</p> <p>如果该PE文件被加载到0x00400000处，那么这个地址就保持不变；但是如果PE文件被加载到其他位置，比如0x00400000+Delta处，</p> <p>那么0x00401120就必须被更新为0x00401120+Delta。</p> <p>&nbsp;</p> <p>也就是说，relocation里面维护的都是本模块内部的绝对地址。</p> <p>&nbsp;</p> <p>连通图。</p> <p>&nbsp;</p> <p>对于只是分析静态的可信目标地址范围，可以去掉会比较浪费时间的disasm to string的功能。</p> <p>&nbsp;</p> <p>在内存中连续的最小逻辑单位是Block</p> <p>Block的特征：</p> <p>1. 起始点是CF/ICF的跳转目标</p> <p>2. 结束点是jmp/ret/jcc或者遇到一个新的起始点</p> <p>&nbsp;</p> <p>需要维护一种结构，来表示内存（主模块的代码段）中哪一段已经被disasm过了，并且方便快速地查询与添加新的范围。</p> <p>而且查询与添加的粒度都是字节对齐。</p> <p>&nbsp;</p> <p>使用vector也是可以的，但是需要每次加入新的区间，都需要重新排序。</p> <p>因为只有排序后的vector，才可以更加高效地查询。</p> <p>&nbsp;</p> <p>二叉查找树，可以使用std::set代替。</p> <p>&nbsp;</p> <p>可以将CFGGenerator 变成 StaticCoverage</p> <p>用来计算CF连通的图，以及根据其他技巧（relocation/export table, gap skipping）获取到的静态图。</p> <p>并且生成TRACE/BBL粒度的统计信息，方便与pin产生的信息做比较。</p> <p>&nbsp;</p> <p>TRACE/BBL是如此的重要，以至于根本没有必要再生成IDA版本的Graph/Block信息。</p> <p>但是Graph是一张连通图的起点，是分析的基本单位，看起来不能直接忽略。</p> <p>&nbsp;</p> <p>那就变成了</p> <p>Graph ---&gt; Trace ---&gt; BBL</p> <p>这三级的解析。</p> <p>&nbsp;</p> <h4>Graph的识别：</h4> <p>起点是call指令的目标地址，以及export table entry/entry point，还可以通过relocation table entry来定位那些indirect call的目标地址。</p> <p>终点是ret指令。（也有一些情况，比如调用了exit/TerminateProcess等终止了进程，也就不会有ret了）</p> <p>&nbsp;</p> <h4>Trace的识别：</h4> <blockquote> <p>Traces usually begin at the target of a taken branch and end with an unconditional branch, including calls and returns. Pin guarantees that a trace is only entered at the top, but it may contain multiple exits. If a branch joins the middle of a trace, Pin constructs a new trace that begins with the branch target.</p></blockquote> <p>起点是branch(jmp/jcc，不包含call)指令的目标地址。</p> <p>终点是jmp/call/ret.</p> <p>&nbsp;</p> <h4>BBL的识别：</h4> <h4></h4> <blockquote> <p>Pin breaks the trace into basic blocks, <em>BBLs</em>. A BBL is a single entrance, single exit sequence of instructions.</p></blockquote> <p>以下面的例子看一下Trace功能BBL的区别：</p> <div id="codeSnippetWrapper"> <div style="border-bottom-style: none; text-align: left; padding-bottom: 0px; line-height: 12pt; border-right-style: none; background-color: #f4f4f4; padding-left: 0px; width: 100%; padding-right: 0px; font-family: 'Courier New', courier, monospace; direction: ltr; border-top-style: none; color: black; font-size: 8pt; border-left-style: none; overflow: visible; padding-top: 0px" id="codeSnippet"><pre style="border-bottom-style: none; text-align: left; padding-bottom: 0px; line-height: 12pt; border-right-style: none; background-color: white; margin: 0em; padding-left: 0px; width: 100%; padding-right: 0px; font-family: 'Courier New', courier, monospace; direction: ltr; border-top-style: none; color: black; font-size: 8pt; border-left-style: none; overflow: visible; padding-top: 0px">##############################################################</pre><!--CRLF--><pre style="border-bottom-style: none; text-align: left; padding-bottom: 0px; line-height: 12pt; border-right-style: none; background-color: #f4f4f4; margin: 0em; padding-left: 0px; width: 100%; padding-right: 0px; font-family: 'Courier New', courier, monospace; direction: ltr; border-top-style: none; color: black; font-size: 8pt; border-left-style: none; overflow: visible; padding-top: 0px">Trace [0x00405c4e - 0x00405c6c]</pre><!--CRLF--><pre style="border-bottom-style: none; text-align: left; padding-bottom: 0px; line-height: 12pt; border-right-style: none; background-color: white; margin: 0em; padding-left: 0px; width: 100%; padding-right: 0px; font-family: 'Courier New', courier, monospace; direction: ltr; border-top-style: none; color: black; font-size: 8pt; border-left-style: none; overflow: visible; padding-top: 0px">BBL [0x00405c4e - 0x00405c57]</pre><!--CRLF--><pre style="border-bottom-style: none; text-align: left; padding-bottom: 0px; line-height: 12pt; border-right-style: none; background-color: #f4f4f4; margin: 0em; padding-left: 0px; width: 100%; padding-right: 0px; font-family: 'Courier New', courier, monospace; direction: ltr; border-top-style: none; color: black; font-size: 8pt; border-left-style: none; overflow: visible; padding-top: 0px">0x00405c4e : mov eax, dword ptr [0x4094d8]</pre><!--CRLF--><pre style="border-bottom-style: none; text-align: left; padding-bottom: 0px; line-height: 12pt; border-right-style: none; background-color: white; margin: 0em; padding-left: 0px; width: 100%; padding-right: 0px; font-family: 'Courier New', courier, monospace; direction: ltr; border-top-style: none; color: black; font-size: 8pt; border-left-style: none; overflow: visible; padding-top: 0px">0x00405c53 : test eax, eax</pre><!--CRLF--><pre style="border-bottom-style: none; text-align: left; padding-bottom: 0px; line-height: 12pt; border-right-style: none; background-color: #f4f4f4; margin: 0em; padding-left: 0px; width: 100%; padding-right: 0px; font-family: 'Courier New', courier, monospace; direction: ltr; border-top-style: none; color: black; font-size: 8pt; border-left-style: none; overflow: visible; padding-top: 0px">--&gt; FallThrough From [0x00405c55] To [0x00405c83]</pre><!--CRLF--><pre style="border-bottom-style: none; text-align: left; padding-bottom: 0px; line-height: 12pt; border-right-style: none; background-color: white; margin: 0em; padding-left: 0px; width: 100%; padding-right: 0px; font-family: 'Courier New', courier, monospace; direction: ltr; border-top-style: none; color: black; font-size: 8pt; border-left-style: none; overflow: visible; padding-top: 0px">0x00405c55 : jnz 0x405c83</pre><!--CRLF--><pre style="border-bottom-style: none; text-align: left; padding-bottom: 0px; line-height: 12pt; border-right-style: none; background-color: #f4f4f4; margin: 0em; padding-left: 0px; width: 100%; padding-right: 0px; font-family: 'Courier New', courier, monospace; direction: ltr; border-top-style: none; color: black; font-size: 8pt; border-left-style: none; overflow: visible; padding-top: 0px">BBL [0x00405c57 - 0x00405c6c]</pre><!--CRLF--><pre style="border-bottom-style: none; text-align: left; padding-bottom: 0px; line-height: 12pt; border-right-style: none; background-color: white; margin: 0em; padding-left: 0px; width: 100%; padding-right: 0px; font-family: 'Courier New', courier, monospace; direction: ltr; border-top-style: none; color: black; font-size: 8pt; border-left-style: none; overflow: visible; padding-top: 0px">0x00405c57 : mov dword ptr [0x4094d8], esi</pre><!--CRLF--><pre style="border-bottom-style: none; text-align: left; padding-bottom: 0px; line-height: 12pt; border-right-style: none; background-color: #f4f4f4; margin: 0em; padding-left: 0px; width: 100%; padding-right: 0px; font-family: 'Courier New', courier, monospace; direction: ltr; border-top-style: none; color: black; font-size: 8pt; border-left-style: none; overflow: visible; padding-top: 0px">0x00405c5d : push 0x40718c</pre><!--CRLF--><pre style="border-bottom-style: none; text-align: left; padding-bottom: 0px; line-height: 12pt; border-right-style: none; background-color: white; margin: 0em; padding-left: 0px; width: 100%; padding-right: 0px; font-family: 'Courier New', courier, monospace; direction: ltr; border-top-style: none; color: black; font-size: 8pt; border-left-style: none; overflow: visible; padding-top: 0px">0x00405c62 : push 0x407180</pre><!--CRLF--><pre style="border-bottom-style: none; text-align: left; padding-bottom: 0px; line-height: 12pt; border-right-style: none; background-color: #f4f4f4; margin: 0em; padding-left: 0px; width: 100%; padding-right: 0px; font-family: 'Courier New', courier, monospace; direction: ltr; border-top-style: none; color: black; font-size: 8pt; border-left-style: none; overflow: visible; padding-top: 0px">--&gt;        Call From [0x00405c67] To [__initterm_e]</pre><!--CRLF--><pre style="border-bottom-style: none; text-align: left; padding-bottom: 0px; line-height: 12pt; border-right-style: none; background-color: white; margin: 0em; padding-left: 0px; width: 100%; padding-right: 0px; font-family: 'Courier New', courier, monospace; direction: ltr; border-top-style: none; color: black; font-size: 8pt; border-left-style: none; overflow: visible; padding-top: 0px">0x00405c67 : call 0x4062b2</pre><!--CRLF--></div></div>
<p>BBL是Trace中对于jcc的划分，正如定义中所说，Trace是一个入口点，多个出口点，因为每个jmp/call/ret都可以算作是出口点，但是jcc并不是Trace的出口点；</p>
<p>而BBL是一个入口点，一个出口点，因此，除了上述Trace的出口点外，jcc也是BBL的出口点。</p>
<p>二者的主要区别，就在于遇到jcc是否结束。</p>
<p>&nbsp;</p>
<p><a href="http://images.cnitblog.com/blog/580388/201404/221138447168186.png"><img style="background-image: none; border-bottom: 0px; border-left: 0px; padding-left: 0px; padding-right: 0px; display: block; float: none; margin-left: auto; border-top: 0px; margin-right: auto; border-right: 0px; padding-top: 0px" title="image" border="0" alt="image" src="http://images.cnitblog.com/blog/580388/201404/221138450609913.png" width="646" height="126"></a></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p><a href="http://images.cnitblog.com/blog/580388/201404/221115394354730.png"><img style="background-image: none; border-right-width: 0px; padding-left: 0px; padding-right: 0px; display: block; float: none; border-top-width: 0px; border-bottom-width: 0px; margin-left: auto; border-left-width: 0px; margin-right: auto; padding-top: 0px" title="image" border="0" alt="image" src="http://images.cnitblog.com/blog/580388/201404/221115419043543.png" width="646" height="398"></a></p>

<p>&nbsp;</p>
<p>到了TRACE级别，就已经一定是连续的了，因此解析在Trace级别就可以了。</p>
<p>而且对于Trace以及BBL，只需要标示其起点及长度就可以了，因此当处理到Split的情况时，也很简单。</p>
<p>&nbsp;</p>
<p>再简化一点，只以trace为基本代码块的单位，而graph并不维护，很显然，trace是所有branch/call的target，对于relocation table中的项目也一定是指向trace的。</p>
<p>&nbsp;</p>
<p>而Graph只作为在寻找trace过程中，防止漏掉的一种手段。</p>
<p>&nbsp;</p>
<p>在解析trace的过程中，也会不断地增加新的target。</p>
<p>&nbsp;</p>
<blockquote>
<p>Compilers separate code and data sections (in order to conform to DEP). In code sections, the only data which can appear are special control structures, such as <strong>jump tables for switch statements</strong> and exception tables.</p></blockquote>
<p>而在正常情况下，code section中也会有很多的gap，比如下面是一个程序在IDA中的布局图，其中蓝色部分是有效代码，而灰色部分就是gap.</p>
<p><a href="http://images.cnitblog.com/blog/580388/201404/231401247325232.png"><img style="background-image: none; border-bottom: 0px; border-left: 0px; padding-left: 0px; padding-right: 0px; display: block; float: none; margin-left: auto; border-top: 0px; margin-right: auto; border-right: 0px; padding-top: 0px" title="image" border="0" alt="image" src="http://images.cnitblog.com/blog/580388/201404/231401252168619.png" width="646" height="50"></a></p>
<p>&nbsp;</p>
<p>1. 看起来还有overlay的情况，因为有的gap长度是negative</p>
<p>2. align的值并不一定是0xCC</p>
<p>&nbsp;</p>
<p>或者说，其实trampoline和align padding都是应该去掉的情况，因为它们后面可能有真正的“代码段”。</p>
<p>&nbsp;</p>
<p>添加一个trim函数，用来将gap头部的已知非代码段内容去掉，如果有剩余，重新作为一个gap，否则结束。</p>
<p>&nbsp;</p>
<p>或者，首先通过align padding来将一个gap进行划分，如果划分之后，什么都没有剩下，那么结束。</p>
<p>&nbsp;</p>
<p>否则，就进行下一个combo trampoline的判断。</p>
<p>&nbsp;</p>
<p>事实上，gap里面的内容，除了align padding, trampoline外，其余的如果是代码，一定是包裹在函数里面的，也就是说一定要有prologue/epilogue，如果没有，也可以剔除掉。</p>
<p>&nbsp;</p>
<p><font color="#9b00d3"><strong>在最后一步linear sweep中，不再增加新的pending trace，因为按道理来说，所有的代码都已经扫描完毕。</strong></font></p>
<p><strong><font color="#9b00d3">所以遇到call/jmp，不中断，形成一个即成的trace，马上向下扫描下一个trace.</font></strong></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p><font color="#9b00d3"><strong>这项任务，只要给予时间，一定能够完成。现只粗略实现。</strong></font></p>
<p>&nbsp;</p>
<p>通过pintool动态地发现Trace，然后查看indirect jump/call是否落到pin发现的有效Trace中。</p></body>
</html>
