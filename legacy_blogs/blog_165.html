<html xmlns="http://www.w3.org/1999/xhtml" lang="zh-cn">
<head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"></head>
<title>Linux&#x786C;&#x4EF6;&#x57FA;&#x7840;</title>
<body><h3>CPU的标志寄存器</h3> <p><a href="http://images.cnitblog.com/blog/580388/201312/20104824-3600bde455f14a4ab95537740e74a9b9.png"><img style="background-image: none; border-right-width: 0px; padding-left: 0px; padding-right: 0px; display: inline; border-top-width: 0px; border-bottom-width: 0px; border-left-width: 0px; padding-top: 0px" title="image" border="0" alt="image" src="http://long123king.github.io/legacy_blogs/img/blog_165_20104825-e77939084c4a4adbaa3267c86bb3e61b.png" width="991" height="774"></a></p> <p>&nbsp;</p> <p>上图是Intel手册中对标志寄存器的图示，几个重要标志如下：</p> <ul> <li>TF (Trap Flag): 单步调试标志， 为1时， CPU每执行一条指令，都产生一个调试异常  <li>IF (Interrupt Flag): 中断允许标志， 为0时，屏蔽“可屏蔽中断”  <li>IOPL (I/O Privilege Level): 输入输出特权级，只有当前程序的CPL数值小于或等于IOPL时，当前程序才能访问IO地址空间，进行IO操作</li></ul> <p>&nbsp;</p> <h3>CR系统控制寄存器</h3> <ol> <li>CR3 ：保存当前进程的页目录的物理地址，改变CR3的值，代表着在不同的地址空间中切换。因为页目录所在的内存也是页对齐，所以CR3中只有高20位有效。  <li>CR2 ：保存产生缺页中断的线性地址，以便根据页表进行调页操作。  <li>CR0 ：包含了多个标志位， 重要的有:  <table border="0" cellspacing="0" cellpadding="2" width="400"> <tbody> <tr> <td valign="top" width="200"> <p>PE位</p></td> <td valign="top" width="200"> <p>保护模式开关 </p></td></tr> <tr> <td valign="top" width="200"> <p>PG位 </p></td> <td valign="top" width="200"> <p>分页机制开关 </p></td></tr></tbody></table></li></ol> <p>&nbsp;</p> <h3>CPU的工作模式</h3> <p>简单来说，CPU允许四种特权级别，每种特权级别支持的指令集有所不同，特权级越高，支持的指令操作也越多。</p> <p>特权级别及其切换的机制是由CPU<strong>保护模式</strong>下的<strong>分段机制</strong>提供的。</p> <p>在实模式下，分段机制十分简单，此时的段从地位上来说，都是相同的，都运行在Ring 0下，都可以完全操控CPU。</p> <p>而在保护模式下，分段机制引入了对于一个段的特权级别的描述，以及对代码段进行敏感操作（比如访问其他数据段，切换到其他代码段去执行，进行任务切换等等）时特权级别的检查机制，从而支持了不同的代码在不同的特权级别下运行。</p> <p>&nbsp;</p> <h3>保护模式下的分段机制</h3> <p>保护模式下段的信息，由简单的16位段寄存器，扩展成64位的复杂的数据结构，称为<strong>段描述符</strong>。</p> <p>出于安全及管理上的考虑，段描述符集中存储在<strong>系统表</strong>中，16位的段寄存器则退化成<strong>段选择子</strong>，用来保存13位的系统表索引，以及2位的特权级别，和1位的全局/局部标识。</p> <p>而为了与实模式下用16位的段寄存器标识段的方法兼容，保护模式采取了<strong>影子寄存器</strong>的方式。</p> <p>比如，当程序通过MOV/POP等指令修改CS/DS等16位的段寄存器时，CPU会自动地到GDT/LDT表中找到其索引的段描述符，并将其加载到影子寄存器中，影子寄存器对于程序完全是透明的，只有CPU知晓它的存在。</p> <p>系统表分为两种：全局表和局部表，全局表有GDT和LDT两张，而局部表为LDT，每个任务有一张。每个任务还有一个TSS段，用来保存任务的上下文信息。</p> <p>&nbsp;</p> <p>分段机制提供了三个方面的保护和限制：</p> <ul> <li>段长限制  <li>段类型限制  <li>特权级别限制</li></ul> <p>&nbsp;</p> <p>段描述符分为三种类型：</p> <ul> <li>存储段， 描述普通的代码、数据和堆栈  <li>系统段， 描述LDT及TSS段，只存在GDT中，其中TSS并不是一个段，而是保护任务上下文信息的一个大型的数据结构  <li>门描述符， 描述的不是一个段，而是一段代码的入口，以及让程序能够顺利地跳转到这段代码执行所必备的特权级别方面的设置</li></ul> <p>&nbsp;</p> <p>门描述符又分为三种类型：</p> <ul> <li>调用门， 用于在同一任务内部，由低特权级别的代码，调用执行高特权级别的代码  <li>任务门， 用于任务切换  <li>中断/陷阱门， 用于提供中断及异常处理程序的入口点</li></ul> <p>&nbsp;</p> <p><font color="#4f81bd">所谓的各种门，可以理解为一个带有特权级别的程序指针。</font></p> <p><font color="#4f81bd">指向“中断/陷阱”的服务程序，或者TSS结构体。</font></p> <p><font color="#4f81bd">由于有了特权级别的限制，这些“程序/数据”不会被普通程序随便地调用，因此起到了保护的作用。</font></p> <p>&nbsp;</p> <p>门描述符保存在全局的IDT表中，IDT表里的项目（即各种门描述符）包含了一个段选择子和一个段内偏移（任务门除外，任务门指向TSS数据结构，不需要段内偏移）。然后再根据段选择子到GDT表中找到对应的代码段，再加上段内偏移，最终找到跳转地址。</p> <p>&nbsp;</p> <p>中断门与陷阱门的唯一区别：中断门会设置IF标志，防止中断嵌套；而陷阱门不会。</p> <p>&nbsp;</p> <p>门的两步特权级别的检查：</p> <ul> <li>门描述符的特权级别检查， CPL &lt;= 门描述符中的DPL  <li>目标代码段描述符的特权级别检查： CPL &gt;= 目标代码段描述符中DPL</li></ul> <p>&nbsp;</p> <p>保证有权限调用这个门，而最终的目标代码的特权级不低于CPL，即最起码是调用更高的特权级别的代码来帮忙处理，这才是门的初衷。</p> <h3>特权级别的检查</h3> <p>当前任务的特权级别CPL，由当前代码段CS段选择子指向的LDT中段描述符中的DPL域决定。</p> <p>&nbsp;</p> <p>而GDT表中的段描述符中的DPL，则表明要访问或者跳转到该段时需要提供的特权级别。</p> <p>&nbsp;</p> <p>当构造一个段选择子以访问或者跳转到一个段时，CPU会检查：</p> <ul> <li>段选择子的RPL &lt;= 其指向的段描述符中DPL （&lt;=代表数值上不大于，即特权级别上不低于）  <li>CPL &lt;= 段选择子指向的段描述符中的DPL</li></ul> <p>&nbsp;</p> <p>这样就保证了，处于Ring 3的用户态程序无法访问或者跳转到Ring 0中的内核态段。</p></body>
</html>
