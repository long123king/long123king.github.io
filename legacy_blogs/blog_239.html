<html xmlns="http://www.w3.org/1999/xhtml" lang="zh-cn">
<head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"></head>
<title>Linux&#x5BF9;&#x7528;&#x6237;&#x6001;&#x7684;&#x52A8;&#x6001;&#x5185;&#x5B58;&#x7BA1;&#x7406;</title>
<body><h3>Linux对内核态内存分配请求与用户态内存分配请求处理上分别对待</h3>
<p>Linux本身信任自己，因此Linux内核请求分配多少内存，就会马上分配相同数量的内存出来。</p>
<p>但内核本身不相信应用程序，而且通常应用程序分配了一段内存，其实只是预定，并不是马上就去访问。由于应用程序的数目比较多，那么这部分只分配了但是没有立即访问的内存就占了很大的比例。</p>
<p>&nbsp;</p>
<p>1. 因此，内核通过Page Fault exception handler来延迟(Defer)对应用程序申请的内存进行分配操作。</p>
<p>2. 用户态的应用程序分配内存时，返回的不是页结构体(struct page)，而是允许应用程序开始使用的一段新的线性地址区间。</p>
<p>&nbsp;</p>
<p>与内核不同，应用程序对其地址空间的占有不是连续的，而是分成一段一段的区间(Interval)。如果应用程序试图访问这些区间没有覆盖到的范围，就会引起异常，这就是常见的Access Denied的错误来源。</p>
<p><span style="color: #ff0000;">对于区间内的内存进行访问时，因为是只是reserved的空间，并没有准备好相应的page，因此会触发Page Fault，关键是要明确谁来处理Page Fault，比如如果后备存储是file，就会由file/inode来负责准备page，如果是动态申请的页，则会返回一个zeroed page。</span></p>
<p>&nbsp;</p>
<p>很显然，这个异常不是CPU发起的，因为这里面的区间是操作系统定义，因此这个异常也是操作系统抛出的。</p>
<p>&nbsp;</p>
<h3>内存描述符</h3>
<p>Memory Descriptor</p>
<p>保存在mm_struct结构体中，由process descriptor-&gt;mm来引用。</p>
<div id="codeSnippetWrapper" style="text-align: left; line-height: 12pt; background-color: #f4f4f4; margin: 20px 0px 10px; width: 97.5%; font-family: 'Courier New', courier, monospace; direction: ltr; max-height: 200px; font-size: 8pt; overflow: auto; cursor: text; border: silver 1px solid; padding: 4px;">
<div id="codeSnippet" style="text-align: left; line-height: 12pt; background-color: #f4f4f4; width: 100%; font-family: 'Courier New', courier, monospace; direction: ltr; color: black; font-size: 8pt; overflow: visible; border-style: none; padding: 0px;">
<pre><span id="lnum1" style="color: #606060;">   1:</span> <span style="color: #0000ff;">struct</span> mm_struct {</pre>
<!--CRLF-->
<pre><span id="lnum2" style="color: #606060;">   2:</span>     <span style="color: #0000ff;">struct</span> vm_area_struct * mmap;        <span style="color: #008000;">/* list of VMAs */</span></pre>
<!--CRLF-->
<pre><span id="lnum3" style="color: #606060;">   3:</span>     <span style="color: #0000ff;">struct</span> rb_root mm_rb;</pre>
<!--CRLF-->
<pre><span id="lnum4" style="color: #606060;">   4:</span>     <span style="color: #0000ff;">struct</span> vm_area_struct * mmap_cache;    <span style="color: #008000;">/* last find_vma result */</span></pre>
<!--CRLF-->
<pre><span id="lnum5" style="color: #606060;">   5:</span> <span style="color: #cc6633;">#ifdef</span> CONFIG_MMU</pre>
<!--CRLF-->
<pre><span id="lnum6" style="color: #606060;">   6:</span>     <span style="color: #0000ff;">unsigned</span> <span style="color: #0000ff;">long</span> (*get_unmapped_area) (<span style="color: #0000ff;">struct</span> file *filp,</pre>
<!--CRLF-->
<pre><span id="lnum7" style="color: #606060;">   7:</span>                 <span style="color: #0000ff;">unsigned</span> <span style="color: #0000ff;">long</span> addr, <span style="color: #0000ff;">unsigned</span> <span style="color: #0000ff;">long</span> len,</pre>
<!--CRLF-->
<pre><span id="lnum8" style="color: #606060;">   8:</span>                 <span style="color: #0000ff;">unsigned</span> <span style="color: #0000ff;">long</span> pgoff, <span style="color: #0000ff;">unsigned</span> <span style="color: #0000ff;">long</span> flags);</pre>
<!--CRLF-->
<pre><span id="lnum9" style="color: #606060;">   9:</span>     <span style="color: #0000ff;">void</span> (*unmap_area) (<span style="color: #0000ff;">struct</span> mm_struct *mm, <span style="color: #0000ff;">unsigned</span> <span style="color: #0000ff;">long</span> addr);</pre>
<!--CRLF-->
<pre><span id="lnum10" style="color: #606060;">  10:</span> <span style="color: #cc6633;">#endif</span></pre>
<!--CRLF-->
<pre><span id="lnum11" style="color: #606060;">  11:</span>     <span style="color: #0000ff;">unsigned</span> <span style="color: #0000ff;">long</span> mmap_base;        <span style="color: #008000;">/* base of mmap area */</span></pre>
<!--CRLF-->
<pre><span id="lnum12" style="color: #606060;">  12:</span>     <span style="color: #0000ff;">unsigned</span> <span style="color: #0000ff;">long</span> task_size;        <span style="color: #008000;">/* size of task vm space */</span></pre>
<!--CRLF-->
<pre><span id="lnum13" style="color: #606060;">  13:</span>     <span style="color: #0000ff;">unsigned</span> <span style="color: #0000ff;">long</span> cached_hole_size;     <span style="color: #008000;">/* if non-zero, the largest hole below free_area_cache */</span></pre>
<!--CRLF-->
<pre><span id="lnum14" style="color: #606060;">  14:</span>     <span style="color: #0000ff;">unsigned</span> <span style="color: #0000ff;">long</span> free_area_cache;        <span style="color: #008000;">/* first hole of size cached_hole_size or larger */</span></pre>
<!--CRLF-->
<pre><span id="lnum15" style="color: #606060;">  15:</span>     pgd_t * pgd;</pre>
<!--CRLF-->
<pre><span id="lnum16" style="color: #606060;">  16:</span>     atomic_t mm_users;            <span style="color: #008000;">/* How many users with user space? */</span></pre>
<!--CRLF-->
<pre><span id="lnum17" style="color: #606060;">  17:</span>     atomic_t mm_count;            <span style="color: #008000;">/* How many references to "struct mm_struct" (users count as 1) */</span></pre>
<!--CRLF-->
<pre><span id="lnum18" style="color: #606060;">  18:</span>     <span style="color: #0000ff;">int</span> map_count;                <span style="color: #008000;">/* number of VMAs */</span></pre>
<!--CRLF-->
<pre><span id="lnum19" style="color: #606060;">  19:</span>&nbsp; </pre>
<!--CRLF-->
<pre><span id="lnum20" style="color: #606060;">  20:</span>     spinlock_t page_table_lock;        <span style="color: #008000;">/* Protects page tables and some counters */</span></pre>
<!--CRLF-->
<pre><span id="lnum21" style="color: #606060;">  21:</span>     <span style="color: #0000ff;">struct</span> rw_semaphore mmap_sem;</pre>
<!--CRLF-->
<pre><span id="lnum22" style="color: #606060;">  22:</span>&nbsp; </pre>
<!--CRLF-->
<pre><span id="lnum23" style="color: #606060;">  23:</span>     <span style="color: #0000ff;">struct</span> list_head mmlist;        <span style="color: #008000;">/* List of maybe swapped mm's.    These are globally strung</span></pre>
<!--CRLF-->
<pre><span id="lnum24" style="color: #606060;">  24:</span> <span style="color: #008000;">                         * together off init_mm.mmlist, and are protected</span></pre>
<!--CRLF-->
<pre><span id="lnum25" style="color: #606060;">  25:</span> <span style="color: #008000;">                         * by mmlist_lock</span></pre>
<!--CRLF-->
<pre><span id="lnum26" style="color: #606060;">  26:</span> <span style="color: #008000;">                         */</span></pre>
<!--CRLF-->
<pre><span id="lnum27" style="color: #606060;">  27:</span>&nbsp; </pre>
<!--CRLF-->
<pre><span id="lnum28" style="color: #606060;">  28:</span>&nbsp; </pre>
<!--CRLF-->
<pre><span id="lnum29" style="color: #606060;">  29:</span>     <span style="color: #0000ff;">unsigned</span> <span style="color: #0000ff;">long</span> hiwater_rss;    <span style="color: #008000;">/* High-watermark of RSS usage */</span></pre>
<!--CRLF-->
<pre><span id="lnum30" style="color: #606060;">  30:</span>     <span style="color: #0000ff;">unsigned</span> <span style="color: #0000ff;">long</span> hiwater_vm;    <span style="color: #008000;">/* High-water virtual memory usage */</span></pre>
<!--CRLF-->
<pre><span id="lnum31" style="color: #606060;">  31:</span>&nbsp; </pre>
<!--CRLF-->
<pre><span id="lnum32" style="color: #606060;">  32:</span>     <span style="color: #0000ff;">unsigned</span> <span style="color: #0000ff;">long</span> total_vm, locked_vm, shared_vm, exec_vm;</pre>
<!--CRLF-->
<pre><span id="lnum33" style="color: #606060;">  33:</span>     <span style="color: #0000ff;">unsigned</span> <span style="color: #0000ff;">long</span> stack_vm, reserved_vm, def_flags, nr_ptes;</pre>
<!--CRLF-->
<pre><span id="lnum34" style="color: #606060;">  34:</span>     <span style="color: #0000ff;">unsigned</span> <span style="color: #0000ff;">long</span> start_code, end_code, start_data, end_data;</pre>
<!--CRLF-->
<pre><span id="lnum35" style="color: #606060;">  35:</span>     <span style="color: #0000ff;">unsigned</span> <span style="color: #0000ff;">long</span> start_brk, brk, start_stack;</pre>
<!--CRLF-->
<pre><span id="lnum36" style="color: #606060;">  36:</span>     <span style="color: #0000ff;">unsigned</span> <span style="color: #0000ff;">long</span> arg_start, arg_end, env_start, env_end;</pre>
<!--CRLF-->
<pre><span id="lnum37" style="color: #606060;">  37:</span>&nbsp; </pre>
<!--CRLF-->
<pre><span id="lnum38" style="color: #606060;">  38:</span>     <span style="color: #0000ff;">unsigned</span> <span style="color: #0000ff;">long</span> saved_auxv[AT_VECTOR_SIZE]; <span style="color: #008000;">/* for /proc/PID/auxv */</span></pre>
<!--CRLF-->
<pre><span id="lnum39" style="color: #606060;">  39:</span>&nbsp; </pre>
<!--CRLF-->
<pre><span id="lnum40" style="color: #606060;">  40:</span>     <span style="color: #008000;">/*</span></pre>
<!--CRLF-->
<pre><span id="lnum41" style="color: #606060;">  41:</span> <span style="color: #008000;">     * Special counters, in some configurations protected by the</span></pre>
<!--CRLF-->
<pre><span id="lnum42" style="color: #606060;">  42:</span> <span style="color: #008000;">     * page_table_lock, in other configurations by being atomic.</span></pre>
<!--CRLF-->
<pre><span id="lnum43" style="color: #606060;">  43:</span> <span style="color: #008000;">     */</span></pre>
<!--CRLF-->
<pre><span id="lnum44" style="color: #606060;">  44:</span>     <span style="color: #0000ff;">struct</span> mm_rss_stat rss_stat;</pre>
<!--CRLF-->
<pre><span id="lnum45" style="color: #606060;">  45:</span>&nbsp; </pre>
<!--CRLF-->
<pre><span id="lnum46" style="color: #606060;">  46:</span>     <span style="color: #0000ff;">struct</span> linux_binfmt *binfmt;</pre>
<!--CRLF-->
<pre><span id="lnum47" style="color: #606060;">  47:</span>&nbsp; </pre>
<!--CRLF-->
<pre><span id="lnum48" style="color: #606060;">  48:</span>     cpumask_var_t cpu_vm_mask_var;</pre>
<!--CRLF-->
<pre><span id="lnum49" style="color: #606060;">  49:</span>&nbsp; </pre>
<!--CRLF-->
<pre><span id="lnum50" style="color: #606060;">  50:</span>     <span style="color: #008000;">/* Architecture-specific MM context */</span></pre>
<!--CRLF-->
<pre><span id="lnum51" style="color: #606060;">  51:</span>     mm_context_t context;</pre>
<!--CRLF-->
<pre><span id="lnum52" style="color: #606060;">  52:</span>&nbsp; </pre>
<!--CRLF-->
<pre><span id="lnum53" style="color: #606060;">  53:</span>     <span style="color: #008000;">/* Swap token stuff */</span></pre>
<!--CRLF-->
<pre><span id="lnum54" style="color: #606060;">  54:</span>     <span style="color: #008000;">/*</span></pre>
<!--CRLF-->
<pre><span id="lnum55" style="color: #606060;">  55:</span> <span style="color: #008000;">     * Last value of global fault stamp as seen by this process.</span></pre>
<!--CRLF-->
<pre><span id="lnum56" style="color: #606060;">  56:</span> <span style="color: #008000;">     * In other words, this value gives an indication of how long</span></pre>
<!--CRLF-->
<pre><span id="lnum57" style="color: #606060;">  57:</span> <span style="color: #008000;">     * it has been since this task got the token.</span></pre>
<!--CRLF-->
<pre><span id="lnum58" style="color: #606060;">  58:</span> <span style="color: #008000;">     * Look at mm/thrash.c</span></pre>
<!--CRLF-->
<pre><span id="lnum59" style="color: #606060;">  59:</span> <span style="color: #008000;">     */</span></pre>
<!--CRLF-->
<pre><span id="lnum60" style="color: #606060;">  60:</span>     <span style="color: #0000ff;">unsigned</span> <span style="color: #0000ff;">int</span> faultstamp;</pre>
<!--CRLF-->
<pre><span id="lnum61" style="color: #606060;">  61:</span>     <span style="color: #0000ff;">unsigned</span> <span style="color: #0000ff;">int</span> token_priority;</pre>
<!--CRLF-->
<pre><span id="lnum62" style="color: #606060;">  62:</span>     <span style="color: #0000ff;">unsigned</span> <span style="color: #0000ff;">int</span> last_interval;</pre>
<!--CRLF-->
<pre><span id="lnum63" style="color: #606060;">  63:</span>&nbsp; </pre>
<!--CRLF-->
<pre><span id="lnum64" style="color: #606060;">  64:</span>     <span style="color: #008000;">/* How many tasks sharing this mm are OOM_DISABLE */</span></pre>
<!--CRLF-->
<pre><span id="lnum65" style="color: #606060;">  65:</span>     atomic_t oom_disable_count;</pre>
<!--CRLF-->
<pre><span id="lnum66" style="color: #606060;">  66:</span>&nbsp; </pre>
<!--CRLF-->
<pre><span id="lnum67" style="color: #606060;">  67:</span>     <span style="color: #0000ff;">unsigned</span> <span style="color: #0000ff;">long</span> flags; <span style="color: #008000;">/* Must use atomic bitops to access the bits */</span></pre>
<!--CRLF-->
<pre><span id="lnum68" style="color: #606060;">  68:</span>&nbsp; </pre>
<!--CRLF-->
<pre><span id="lnum69" style="color: #606060;">  69:</span>     <span style="color: #0000ff;">struct</span> core_state *core_state; <span style="color: #008000;">/* coredumping support */</span></pre>
<!--CRLF-->
<pre><span id="lnum70" style="color: #606060;">  70:</span> <span style="color: #cc6633;">#ifdef</span> CONFIG_AIO</pre>
<!--CRLF-->
<pre><span id="lnum71" style="color: #606060;">  71:</span>     spinlock_t        ioctx_lock;</pre>
<!--CRLF-->
<pre><span id="lnum72" style="color: #606060;">  72:</span>     <span style="color: #0000ff;">struct</span> hlist_head    ioctx_list;</pre>
<!--CRLF-->
<pre><span id="lnum73" style="color: #606060;">  73:</span> <span style="color: #cc6633;">#endif</span></pre>
<!--CRLF-->
<pre><span id="lnum74" style="color: #606060;">  74:</span> <span style="color: #cc6633;">#ifdef</span> CONFIG_MM_OWNER</pre>
<!--CRLF-->
<pre><span id="lnum75" style="color: #606060;">  75:</span>     <span style="color: #008000;">/*</span></pre>
<!--CRLF-->
<pre><span id="lnum76" style="color: #606060;">  76:</span> <span style="color: #008000;">     * "owner" points to a task that is regarded as the canonical</span></pre>
<!--CRLF-->
<pre><span id="lnum77" style="color: #606060;">  77:</span> <span style="color: #008000;">     * user/owner of this mm. All of the following must be true in</span></pre>
<!--CRLF-->
<pre><span id="lnum78" style="color: #606060;">  78:</span> <span style="color: #008000;">     * order for it to be changed:</span></pre>
<!--CRLF-->
<pre><span id="lnum79" style="color: #606060;">  79:</span> <span style="color: #008000;">     *</span></pre>
<!--CRLF-->
<pre><span id="lnum80" style="color: #606060;">  80:</span> <span style="color: #008000;">     * current == mm-&gt;owner</span></pre>
<!--CRLF-->
<pre><span id="lnum81" style="color: #606060;">  81:</span> <span style="color: #008000;">     * current-&gt;mm != mm</span></pre>
<!--CRLF-->
<pre><span id="lnum82" style="color: #606060;">  82:</span> <span style="color: #008000;">     * new_owner-&gt;mm == mm</span></pre>
<!--CRLF-->
<pre><span id="lnum83" style="color: #606060;">  83:</span> <span style="color: #008000;">     * new_owner-&gt;alloc_lock is held</span></pre>
<!--CRLF-->
<pre><span id="lnum84" style="color: #606060;">  84:</span> <span style="color: #008000;">     */</span></pre>
<!--CRLF-->
<pre><span id="lnum85" style="color: #606060;">  85:</span>     <span style="color: #0000ff;">struct</span> task_struct __rcu *owner;</pre>
<!--CRLF-->
<pre><span id="lnum86" style="color: #606060;">  86:</span> <span style="color: #cc6633;">#endif</span></pre>
<!--CRLF-->
<pre><span id="lnum87" style="color: #606060;">  87:</span>&nbsp; </pre>
<!--CRLF-->
<pre><span id="lnum88" style="color: #606060;">  88:</span>     <span style="color: #008000;">/* store ref to file /proc/&lt;pid&gt;/exe symlink points to */</span></pre>
<!--CRLF-->
<pre><span id="lnum89" style="color: #606060;">  89:</span>     <span style="color: #0000ff;">struct</span> file *exe_file;</pre>
<!--CRLF-->
<pre><span id="lnum90" style="color: #606060;">  90:</span>     <span style="color: #0000ff;">unsigned</span> <span style="color: #0000ff;">long</span> num_exe_file_vmas;</pre>
<!--CRLF-->
<pre><span id="lnum91" style="color: #606060;">  91:</span> <span style="color: #cc6633;">#ifdef</span> CONFIG_MMU_NOTIFIER</pre>
<!--CRLF-->
<pre><span id="lnum92" style="color: #606060;">  92:</span>     <span style="color: #0000ff;">struct</span> mmu_notifier_mm *mmu_notifier_mm;</pre>
<!--CRLF-->
<pre><span id="lnum93" style="color: #606060;">  93:</span> <span style="color: #cc6633;">#endif</span></pre>
<!--CRLF-->
<pre><span id="lnum94" style="color: #606060;">  94:</span> <span style="color: #cc6633;">#ifdef</span> CONFIG_TRANSPARENT_HUGEPAGE</pre>
<!--CRLF-->
<pre><span id="lnum95" style="color: #606060;">  95:</span>     pgtable_t pmd_huge_pte; <span style="color: #008000;">/* protected by page_table_lock */</span></pre>
<!--CRLF-->
<pre><span id="lnum96" style="color: #606060;">  96:</span> <span style="color: #cc6633;">#endif</span></pre>
<!--CRLF-->
<pre><span id="lnum97" style="color: #606060;">  97:</span> <span style="color: #cc6633;">#ifdef</span> CONFIG_CPUMASK_OFFSTACK</pre>
<!--CRLF-->
<pre><span id="lnum98" style="color: #606060;">  98:</span>     <span style="color: #0000ff;">struct</span> cpumask cpumask_allocation;</pre>
<!--CRLF-->
<pre><span id="lnum99" style="color: #606060;">  99:</span> <span style="color: #cc6633;">#endif</span></pre>
<!--CRLF-->
<pre><span id="lnum100" style="color: #606060;"> 100:</span> };</pre>
<!--CRLF--></div>
</div>
<p>每个内存区间，通过struct vm_area_struct来描述。</p>
<p>每个内存描述符中，通过两种方式来管理内存区间：</p>
<p>1. mmap，以数组的形式保存属于该内存中的所有内存区间。<span style="color: #ff0000;">【方便遍历，从低地址到高地址】</span></p>
<p>2. mm_rb，通过&ldquo;红黑树&rdquo;的方式管理内存中的所有内存区间。<span style="color: #ff0000;">【方便查找】</span></p>
<p>&nbsp;</p>
<p>其他重要的成员：</p>
<p>pgd, 保存本进程相关的页目录地址。<span style="color: #ff0000;">【页目录的线性地址， 参考：<a title="http://www.cnblogs.com/long123king/p/3506893.html" href="http://www.cnblogs.com/long123king/p/3506893.html">http://www.cnblogs.com/long123king/p/3506893.html</a>】</span></p>
<p>map_count, 该内存中内存区间的个数。</p>
<p>mmlist，（struct list_head结构体），将该内存描述符保存在一个链表中。</p>
<p>start_code/end_code/start_data/end_data, 顾名思义。</p>
<p>brk, 当前进程的堆的地址。</p>
<p>context, 当前进程的上下文信息，其实就是LDT的地址</p>
<p>&nbsp;</p>
<h3>内核线程的内存描述符</h3>
<div id="codeSnippetWrapper" style="text-align: left; line-height: 12pt; background-color: #f4f4f4; margin: 20px 0px 10px; width: 97.5%; font-family: 'Courier New', courier, monospace; direction: ltr; max-height: 200px; font-size: 8pt; overflow: auto; cursor: text; border: silver 1px solid; padding: 4px;">
<div id="codeSnippet" style="text-align: left; line-height: 12pt; background-color: #f4f4f4; width: 100%; font-family: 'Courier New', courier, monospace; direction: ltr; color: black; font-size: 8pt; overflow: visible; border-style: none; padding: 0px;">
<pre><span id="lnum1" style="color: #606060;">   1:</span> <span style="color: #0000ff;">struct</span> task_struct {</pre>
<!--CRLF-->
<pre><span id="lnum2" style="color: #606060;">   2:</span>&nbsp; </pre>
<!--CRLF-->
<pre><span id="lnum3" style="color: #606060;">   3:</span> ......</pre>
<!--CRLF-->
<pre><span id="lnum4" style="color: #606060;">   4:</span>&nbsp; </pre>
<!--CRLF-->
<pre><span id="lnum5" style="color: #606060;">   5:</span> <span style="color: #0000ff;">struct</span> mm_struct *mm, *active_mm;</pre>
<!--CRLF-->
<pre><span id="lnum6" style="color: #606060;">   6:</span> ......</pre>
<!--CRLF-->
<pre><span id="lnum7" style="color: #606060;">   7:</span>&nbsp; </pre>
<!--CRLF-->
<pre><span id="lnum8" style="color: #606060;">   8:</span> }</pre>
<!--CRLF--></div>
</div>
<p>内核线程只在内核态下运行，因此它不使用0~3GB的线性地址空间，也没有memory region的概念，因为内核态的线性地址空间是连续的。</p>
<p>因为每个进程的页表中，对于3GB-4GB的地址空间的页表项都是相同的，因此，内核态的进程使用哪个进程的页目录项都是一样的，而且为了避免反复地刷新TLB和CPU的硬件缓存，内核就尽量使用上一个进程的页目录。</p>
<p>&nbsp;</p>
<p>因此在task_struct中有两个mm_struct（内存描述符成员）：mm和active_mm</p>
<p>对于普通进程，这两个成员是相同的，都指向当前进程的内存描述符成员；</p>
<p>对于内核线程，它没有对应的内存描述符，因此mm为NULL。而当一个内核线程被调度执行时，它的task_struct结构体中的active_mm成员被初始化为前一个正在执行的进程的active_mm成员。</p>
<p>&nbsp;</p>
<p>每当内核态对应的页表项需要重新映射时，内核更新swapper_pg_dir中定义的内核全局页表规范集合。</p>
<p>然后，在Page Fault handler处理时，会把这次的改动更新到每个进程的页目录中。</p>
<p>&nbsp;</p>
<h3>内存区间(Memory Region)</h3>
<div id="codeSnippetWrapper" style="text-align: left; line-height: 12pt; background-color: #f4f4f4; margin: 20px 0px 10px; width: 97.5%; font-family: 'Courier New', courier, monospace; direction: ltr; max-height: 200px; font-size: 8pt; overflow: auto; cursor: text; border: silver 1px solid; padding: 4px;">
<div id="codeSnippet" style="text-align: left; line-height: 12pt; background-color: #f4f4f4; width: 100%; font-family: 'Courier New', courier, monospace; direction: ltr; color: black; font-size: 8pt; overflow: visible; border-style: none; padding: 0px;">
<pre><span id="lnum1" style="color: #606060;">   1:</span> <span style="color: #008000;">/*</span></pre>
<!--CRLF-->
<pre><span id="lnum2" style="color: #606060;">   2:</span> <span style="color: #008000;"> * This struct defines a memory VMM memory area. There is one of these</span></pre>
<!--CRLF-->
<pre><span id="lnum3" style="color: #606060;">   3:</span> <span style="color: #008000;"> * per VM-area/task.  A VM area is any part of the process virtual memory</span></pre>
<!--CRLF-->
<pre><span id="lnum4" style="color: #606060;">   4:</span> <span style="color: #008000;"> * space that has a special rule for the page-fault handlers (ie a shared</span></pre>
<!--CRLF-->
<pre><span id="lnum5" style="color: #606060;">   5:</span> <span style="color: #008000;"> * library, the executable area etc).</span></pre>
<!--CRLF-->
<pre><span id="lnum6" style="color: #606060;">   6:</span> <span style="color: #008000;"> */</span></pre>
<!--CRLF-->
<pre><span id="lnum7" style="color: #606060;">   7:</span> <span style="color: #0000ff;">struct</span> vm_area_struct {</pre>
<!--CRLF-->
<pre><span id="lnum8" style="color: #606060;">   8:</span>     <span style="color: #0000ff;">struct</span> mm_struct * vm_mm;    <span style="color: #008000;">/* The address space we belong to. */</span></pre>
<!--CRLF-->
<pre><span id="lnum9" style="color: #606060;">   9:</span>     <span style="color: #0000ff;">unsigned</span> <span style="color: #0000ff;">long</span> vm_start;        <span style="color: #008000;">/* Our start address within vm_mm. */</span></pre>
<!--CRLF-->
<pre><span id="lnum10" style="color: #606060;">  10:</span>     <span style="color: #0000ff;">unsigned</span> <span style="color: #0000ff;">long</span> vm_end;        <span style="color: #008000;">/* The first byte after our end address</span></pre>
<!--CRLF-->
<pre><span id="lnum11" style="color: #606060;">  11:</span> <span style="color: #008000;">                       within vm_mm. */</span></pre>
<!--CRLF-->
<pre><span id="lnum12" style="color: #606060;">  12:</span>&nbsp; </pre>
<!--CRLF-->
<pre><span id="lnum13" style="color: #606060;">  13:</span>     <span style="color: #008000;">/* linked list of VM areas per task, sorted by address */</span></pre>
<!--CRLF-->
<pre><span id="lnum14" style="color: #606060;">  14:</span>     <span style="color: #0000ff;">struct</span> vm_area_struct *vm_next, *vm_prev;</pre>
<!--CRLF-->
<pre><span id="lnum15" style="color: #606060;">  15:</span>&nbsp; </pre>
<!--CRLF-->
<pre><span id="lnum16" style="color: #606060;">  16:</span>     pgprot_t vm_page_prot;        <span style="color: #008000;">/* Access permissions of this VMA. */</span></pre>
<!--CRLF-->
<pre><span id="lnum17" style="color: #606060;">  17:</span>     <span style="color: #0000ff;">unsigned</span> <span style="color: #0000ff;">long</span> vm_flags;        <span style="color: #008000;">/* Flags, see mm.h. */</span></pre>
<!--CRLF-->
<pre><span id="lnum18" style="color: #606060;">  18:</span>&nbsp; </pre>
<!--CRLF-->
<pre><span id="lnum19" style="color: #606060;">  19:</span>     <span style="color: #0000ff;">struct</span> rb_node vm_rb;</pre>
<!--CRLF-->
<pre><span id="lnum20" style="color: #606060;">  20:</span>&nbsp; </pre>
<!--CRLF-->
<pre><span id="lnum21" style="color: #606060;">  21:</span>     <span style="color: #008000;">/*</span></pre>
<!--CRLF-->
<pre><span id="lnum22" style="color: #606060;">  22:</span> <span style="color: #008000;">     * For areas with an address space and backing store,</span></pre>
<!--CRLF-->
<pre><span id="lnum23" style="color: #606060;">  23:</span> <span style="color: #008000;">     * linkage into the address_space-&gt;i_mmap prio tree, or</span></pre>
<!--CRLF-->
<pre><span id="lnum24" style="color: #606060;">  24:</span> <span style="color: #008000;">     * linkage to the list of like vmas hanging off its node, or</span></pre>
<!--CRLF-->
<pre><span id="lnum25" style="color: #606060;">  25:</span> <span style="color: #008000;">     * linkage of vma in the address_space-&gt;i_mmap_nonlinear list.</span></pre>
<!--CRLF-->
<pre><span id="lnum26" style="color: #606060;">  26:</span> <span style="color: #008000;">     */</span></pre>
<!--CRLF-->
<pre><span id="lnum27" style="color: #606060;">  27:</span>     <span style="color: #0000ff;">union</span> {</pre>
<!--CRLF-->
<pre><span id="lnum28" style="color: #606060;">  28:</span>         <span style="color: #0000ff;">struct</span> {</pre>
<!--CRLF-->
<pre><span id="lnum29" style="color: #606060;">  29:</span>             <span style="color: #0000ff;">struct</span> list_head list;</pre>
<!--CRLF-->
<pre><span id="lnum30" style="color: #606060;">  30:</span>             <span style="color: #0000ff;">void</span> *parent;    <span style="color: #008000;">/* aligns with prio_tree_node parent */</span></pre>
<!--CRLF-->
<pre><span id="lnum31" style="color: #606060;">  31:</span>             <span style="color: #0000ff;">struct</span> vm_area_struct *head;</pre>
<!--CRLF-->
<pre><span id="lnum32" style="color: #606060;">  32:</span>         } vm_set;</pre>
<!--CRLF-->
<pre><span id="lnum33" style="color: #606060;">  33:</span>&nbsp; </pre>
<!--CRLF-->
<pre><span id="lnum34" style="color: #606060;">  34:</span>         <span style="color: #0000ff;">struct</span> raw_prio_tree_node prio_tree_node;</pre>
<!--CRLF-->
<pre><span id="lnum35" style="color: #606060;">  35:</span>     } shared;</pre>
<!--CRLF-->
<pre><span id="lnum36" style="color: #606060;">  36:</span>&nbsp; </pre>
<!--CRLF-->
<pre><span id="lnum37" style="color: #606060;">  37:</span>     <span style="color: #008000;">/*</span></pre>
<!--CRLF-->
<pre><span id="lnum38" style="color: #606060;">  38:</span> <span style="color: #008000;">     * A file's MAP_PRIVATE vma can be in both i_mmap tree and anon_vma</span></pre>
<!--CRLF-->
<pre><span id="lnum39" style="color: #606060;">  39:</span> <span style="color: #008000;">     * list, after a COW of one of the file pages.    A MAP_SHARED vma</span></pre>
<!--CRLF-->
<pre><span id="lnum40" style="color: #606060;">  40:</span> <span style="color: #008000;">     * can only be in the i_mmap tree.  An anonymous MAP_PRIVATE, stack</span></pre>
<!--CRLF-->
<pre><span id="lnum41" style="color: #606060;">  41:</span> <span style="color: #008000;">     * or brk vma (with NULL file) can only be in an anon_vma list.</span></pre>
<!--CRLF-->
<pre><span id="lnum42" style="color: #606060;">  42:</span> <span style="color: #008000;">     */</span></pre>
<!--CRLF-->
<pre><span id="lnum43" style="color: #606060;">  43:</span>     <span style="color: #0000ff;">struct</span> list_head anon_vma_chain; <span style="color: #008000;">/* Serialized by mmap_sem &amp;</span></pre>
<!--CRLF-->
<pre><span id="lnum44" style="color: #606060;">  44:</span> <span style="color: #008000;">                      * page_table_lock */</span></pre>
<!--CRLF-->
<pre><span id="lnum45" style="color: #606060;">  45:</span>     <span style="color: #0000ff;">struct</span> anon_vma *anon_vma;    <span style="color: #008000;">/* Serialized by page_table_lock */</span></pre>
<!--CRLF-->
<pre><span id="lnum46" style="color: #606060;">  46:</span>&nbsp; </pre>
<!--CRLF-->
<pre><span id="lnum47" style="color: #606060;">  47:</span>     <span style="color: #008000;">/* Function pointers to deal with this struct. */</span></pre>
<!--CRLF-->
<pre><span id="lnum48" style="color: #606060;">  48:</span>     <span style="color: #0000ff;">const</span> <span style="color: #0000ff;">struct</span> vm_operations_struct *vm_ops;</pre>
<!--CRLF-->
<pre><span id="lnum49" style="color: #606060;">  49:</span>&nbsp; </pre>
<!--CRLF-->
<pre><span id="lnum50" style="color: #606060;">  50:</span>     <span style="color: #008000;">/* Information about our backing store: */</span></pre>
<!--CRLF-->
<pre><span id="lnum51" style="color: #606060;">  51:</span>     <span style="color: #0000ff;">unsigned</span> <span style="color: #0000ff;">long</span> vm_pgoff;        <span style="color: #008000;">/* Offset (within vm_file) in PAGE_SIZE</span></pre>
<!--CRLF-->
<pre><span id="lnum52" style="color: #606060;">  52:</span> <span style="color: #008000;">                       units, *not* PAGE_CACHE_SIZE */</span></pre>
<!--CRLF-->
<pre><span id="lnum53" style="color: #606060;">  53:</span>     <span style="color: #0000ff;">struct</span> file * vm_file;        <span style="color: #008000;">/* File we map to (can be NULL). */</span></pre>
<!--CRLF-->
<pre><span id="lnum54" style="color: #606060;">  54:</span>     <span style="color: #0000ff;">void</span> * vm_private_data;        <span style="color: #008000;">/* was vm_pte (shared mem) */</span></pre>
<!--CRLF-->
<pre><span id="lnum55" style="color: #606060;">  55:</span>&nbsp; </pre>
<!--CRLF-->
<pre><span id="lnum56" style="color: #606060;">  56:</span> <span style="color: #cc6633;">#ifndef</span> CONFIG_MMU</pre>
<!--CRLF-->
<pre><span id="lnum57" style="color: #606060;">  57:</span>     <span style="color: #0000ff;">struct</span> vm_region *vm_region;    <span style="color: #008000;">/* NOMMU mapping region */</span></pre>
<!--CRLF-->
<pre><span id="lnum58" style="color: #606060;">  58:</span> <span style="color: #cc6633;">#endif</span></pre>
<!--CRLF-->
<pre><span id="lnum59" style="color: #606060;">  59:</span> <span style="color: #cc6633;">#ifdef</span> CONFIG_NUMA</pre>
<!--CRLF-->
<pre><span id="lnum60" style="color: #606060;">  60:</span>     <span style="color: #0000ff;">struct</span> mempolicy *vm_policy;    <span style="color: #008000;">/* NUMA policy for the VMA */</span></pre>
<!--CRLF-->
<pre><span id="lnum61" style="color: #606060;">  61:</span> <span style="color: #cc6633;">#endif</span></pre>
<!--CRLF-->
<pre><span id="lnum62" style="color: #606060;">  62:</span> };</pre>
<!--CRLF--></div>
</div>
<p>在mm_struct中，通过两种方式可以索引到vm_area_struct，分别是mmap成员，它维护一条按线性内存地址升序的双链表；还有一个是mm_rb，它维护一个&ldquo;红黑树&rdquo;。</p>
<p>&nbsp;</p>
<p>但是，实际上，对于一个内存区间结构体(vm_area_struct)的对象来说，只有一个实例来代表这个内存区间，只不过是通过两种数据结构来共同维护它。</p>
<p>&nbsp;</p>
<p>这样做的好处，是两种数据结构可以分别用于不同的目的：</p>
<p>1， 红黑树，用来根据一个指定的线性地址，快速地找到它所在的内存区间。</p>
<p>2， 双链表，用于按顺序遍历全部的内存区间。</p>
<p>&nbsp;</p>
<h3>页的访问属性</h3>
<p>保存在三个地方:</p>
<p>1. 每个页表项中，有相应的flag，代表其对应的页的访问属性。这是x86硬件用来检查页是否可以访问的依据；</p>
<p>2. 每个页描述符struct page中，有相应的flag。这是为操作系统的检查提供的；</p>
<p>3. 每个内存区间vm_area_struct中，有相应的flag，代表该区间中的所有的页的访问属性。</p>
<p>&nbsp;</p>
<h3>对于Memory Region的几种操作</h3>
<p>find_vma, 找到与目标地址最靠近的内存区间</p>
<div id="codeSnippetWrapper" style="text-align: left; line-height: 12pt; background-color: #f4f4f4; margin: 20px 0px 10px; width: 97.5%; font-family: 'Courier New', courier, monospace; direction: ltr; max-height: 200px; font-size: 8pt; overflow: auto; cursor: text; border: silver 1px solid; padding: 4px;">
<div id="codeSnippet" style="text-align: left; line-height: 12pt; background-color: #f4f4f4; width: 100%; font-family: 'Courier New', courier, monospace; direction: ltr; color: black; font-size: 8pt; overflow: visible; border-style: none; padding: 0px;">
<pre><span id="lnum1" style="color: #606060;">   1:</span> <span style="color: #008000;">/* Look up the first VMA which satisfies  addr &lt; vm_end,  NULL if none. */</span></pre>
<!--CRLF-->
<pre><span id="lnum2" style="color: #606060;">   2:</span> <span style="color: #0000ff;">struct</span> vm_area_struct *find_vma(<span style="color: #0000ff;">struct</span> mm_struct *mm, <span style="color: #0000ff;">unsigned</span> <span style="color: #0000ff;">long</span> addr)</pre>
<!--CRLF-->
<pre><span id="lnum3" style="color: #606060;">   3:</span> {</pre>
<!--CRLF-->
<pre><span id="lnum4" style="color: #606060;">   4:</span>     <span style="color: #0000ff;">struct</span> vm_area_struct *vma = NULL;</pre>
<!--CRLF-->
<pre><span id="lnum5" style="color: #606060;">   5:</span>&nbsp; </pre>
<!--CRLF-->
<pre><span id="lnum6" style="color: #606060;">   6:</span>     <span style="color: #0000ff;">if</span> (mm) {</pre>
<!--CRLF-->
<pre><span id="lnum7" style="color: #606060;">   7:</span>         <span style="color: #008000;">/* Check the cache first. */</span></pre>
<!--CRLF-->
<pre><span id="lnum8" style="color: #606060;">   8:</span>         <span style="color: #008000;">/* (Cache hit rate is typically around 35%.) */</span></pre>
<!--CRLF-->
<pre><span id="lnum9" style="color: #606060;">   9:</span>         vma = ACCESS_ONCE(mm-&gt;mmap_cache);</pre>
<!--CRLF-->
<pre><span id="lnum10" style="color: #606060;">  10:</span>         <span style="color: #0000ff;">if</span> (!(vma &amp;&amp; vma-&gt;vm_end &gt; addr &amp;&amp; vma-&gt;vm_start &lt;= addr)) {</pre>
<!--CRLF-->
<pre><span id="lnum11" style="color: #606060;">  11:</span>             <span style="color: #0000ff;">struct</span> rb_node * rb_node;</pre>
<!--CRLF-->
<pre><span id="lnum12" style="color: #606060;">  12:</span>&nbsp; </pre>
<!--CRLF-->
<pre><span id="lnum13" style="color: #606060;">  13:</span>             rb_node = mm-&gt;mm_rb.rb_node;</pre>
<!--CRLF-->
<pre><span id="lnum14" style="color: #606060;">  14:</span>             vma = NULL;</pre>
<!--CRLF-->
<pre><span id="lnum15" style="color: #606060;">  15:</span>&nbsp; </pre>
<!--CRLF-->
<pre><span id="lnum16" style="color: #606060;">  16:</span>             <span style="color: #0000ff;">while</span> (rb_node) {</pre>
<!--CRLF-->
<pre><span id="lnum17" style="color: #606060;">  17:</span>                 <span style="color: #0000ff;">struct</span> vm_area_struct * vma_tmp;</pre>
<!--CRLF-->
<pre><span id="lnum18" style="color: #606060;">  18:</span>&nbsp; </pre>
<!--CRLF-->
<pre><span id="lnum19" style="color: #606060;">  19:</span>                 vma_tmp = rb_entry(rb_node,</pre>
<!--CRLF-->
<pre><span id="lnum20" style="color: #606060;">  20:</span>                         <span style="color: #0000ff;">struct</span> vm_area_struct, vm_rb);</pre>
<!--CRLF-->
<pre><span id="lnum21" style="color: #606060;">  21:</span>&nbsp; </pre>
<!--CRLF-->
<pre><span id="lnum22" style="color: #606060;">  22:</span>                 <span style="color: #0000ff;">if</span> (vma_tmp-&gt;vm_end &gt; addr) {</pre>
<!--CRLF-->
<pre><span id="lnum23" style="color: #606060;">  23:</span>                     vma = vma_tmp;</pre>
<!--CRLF-->
<pre><span id="lnum24" style="color: #606060;">  24:</span>                     <span style="color: #0000ff;">if</span> (vma_tmp-&gt;vm_start &lt;= addr)</pre>
<!--CRLF-->
<pre><span id="lnum25" style="color: #606060;">  25:</span>                         <span style="color: #0000ff;">break</span>;</pre>
<!--CRLF-->
<pre><span id="lnum26" style="color: #606060;">  26:</span>                     rb_node = rb_node-&gt;rb_left;</pre>
<!--CRLF-->
<pre><span id="lnum27" style="color: #606060;">  27:</span>                 } <span style="color: #0000ff;">else</span></pre>
<!--CRLF-->
<pre><span id="lnum28" style="color: #606060;">  28:</span>                     rb_node = rb_node-&gt;rb_right;</pre>
<!--CRLF-->
<pre><span id="lnum29" style="color: #606060;">  29:</span>             }</pre>
<!--CRLF-->
<pre><span id="lnum30" style="color: #606060;">  30:</span>             <span style="color: #0000ff;">if</span> (vma)</pre>
<!--CRLF-->
<pre><span id="lnum31" style="color: #606060;">  31:</span>                 mm-&gt;mmap_cache = vma;</pre>
<!--CRLF-->
<pre><span id="lnum32" style="color: #606060;">  32:</span>         }</pre>
<!--CRLF-->
<pre><span id="lnum33" style="color: #606060;">  33:</span>     }</pre>
<!--CRLF-->
<pre><span id="lnum34" style="color: #606060;">  34:</span>     <span style="color: #0000ff;">return</span> vma;</pre>
<!--CRLF-->
<pre><span id="lnum35" style="color: #606060;">  35:</span> }</pre>
<!--CRLF--></div>
</div>
<p>find_vma_intersection, 找到与目标地址范围相交的内存区间</p>
<div id="codeSnippetWrapper" style="text-align: left; line-height: 12pt; background-color: #f4f4f4; margin: 20px 0px 10px; width: 97.5%; font-family: 'Courier New', courier, monospace; direction: ltr; max-height: 200px; font-size: 8pt; overflow: auto; cursor: text; border: silver 1px solid; padding: 4px;">
<div id="codeSnippet" style="text-align: left; line-height: 12pt; background-color: #f4f4f4; width: 100%; font-family: 'Courier New', courier, monospace; direction: ltr; color: black; font-size: 8pt; overflow: visible; border-style: none; padding: 0px;">
<pre><span id="lnum1" style="color: #606060;">   1:</span> <span style="color: #008000;">/* Look up the first VMA which intersects the interval start_addr..end_addr-1,</span></pre>
<!--CRLF-->
<pre><span id="lnum2" style="color: #606060;">   2:</span> <span style="color: #008000;">   NULL if none.  Assume start_addr &lt; end_addr. */</span></pre>
<!--CRLF-->
<pre><span id="lnum3" style="color: #606060;">   3:</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">inline</span> <span style="color: #0000ff;">struct</span> vm_area_struct * find_vma_intersection(<span style="color: #0000ff;">struct</span> mm_struct * mm, <span style="color: #0000ff;">unsigned</span> <span style="color: #0000ff;">long</span> start_addr, <span style="color: #0000ff;">unsigned</span> <span style="color: #0000ff;">long</span> end_addr)</pre>
<!--CRLF-->
<pre><span id="lnum4" style="color: #606060;">   4:</span> {</pre>
<!--CRLF-->
<pre><span id="lnum5" style="color: #606060;">   5:</span>     <span style="color: #0000ff;">struct</span> vm_area_struct * vma = find_vma(mm,start_addr);</pre>
<!--CRLF-->
<pre><span id="lnum6" style="color: #606060;">   6:</span>&nbsp; </pre>
<!--CRLF-->
<pre><span id="lnum7" style="color: #606060;">   7:</span>     <span style="color: #0000ff;">if</span> (vma &amp;&amp; end_addr &lt;= vma-&gt;vm_start)</pre>
<!--CRLF-->
<pre><span id="lnum8" style="color: #606060;">   8:</span>         vma = NULL;</pre>
<!--CRLF-->
<pre><span id="lnum9" style="color: #606060;">   9:</span>     <span style="color: #0000ff;">return</span> vma;</pre>
<!--CRLF-->
<pre><span id="lnum10" style="color: #606060;">  10:</span> }</pre>
<!--CRLF--></div>
</div>
<p>get_unmapped_area, 找到符合指定长度的内存区间之间的空洞，可以作为新建的内存区间的候选位置</p>
<div id="codeSnippetWrapper" style="text-align: left; line-height: 12pt; background-color: #f4f4f4; margin: 20px 0px 10px; width: 97.5%; font-family: 'Courier New', courier, monospace; direction: ltr; max-height: 200px; font-size: 8pt; overflow: auto; cursor: text; border: silver 1px solid; padding: 4px;">
<div id="codeSnippet" style="text-align: left; line-height: 12pt; background-color: #f4f4f4; width: 100%; font-family: 'Courier New', courier, monospace; direction: ltr; color: black; font-size: 8pt; overflow: visible; border-style: none; padding: 0px;">
<pre><span id="lnum1" style="color: #606060;">   1:</span> <span style="color: #0000ff;">unsigned</span> <span style="color: #0000ff;">long</span></pre>
<!--CRLF-->
<pre><span id="lnum2" style="color: #606060;">   2:</span> get_unmapped_area(<span style="color: #0000ff;">struct</span> file *file, <span style="color: #0000ff;">unsigned</span> <span style="color: #0000ff;">long</span> addr, <span style="color: #0000ff;">unsigned</span> <span style="color: #0000ff;">long</span> len,</pre>
<!--CRLF-->
<pre><span id="lnum3" style="color: #606060;">   3:</span>         <span style="color: #0000ff;">unsigned</span> <span style="color: #0000ff;">long</span> pgoff, <span style="color: #0000ff;">unsigned</span> <span style="color: #0000ff;">long</span> flags)</pre>
<!--CRLF-->
<pre><span id="lnum4" style="color: #606060;">   4:</span> {</pre>
<!--CRLF-->
<pre><span id="lnum5" style="color: #606060;">   5:</span>     <span style="color: #0000ff;">unsigned</span> <span style="color: #0000ff;">long</span> (*get_area)(<span style="color: #0000ff;">struct</span> file *, <span style="color: #0000ff;">unsigned</span> <span style="color: #0000ff;">long</span>,</pre>
<!--CRLF-->
<pre><span id="lnum6" style="color: #606060;">   6:</span>                   <span style="color: #0000ff;">unsigned</span> <span style="color: #0000ff;">long</span>, <span style="color: #0000ff;">unsigned</span> <span style="color: #0000ff;">long</span>, <span style="color: #0000ff;">unsigned</span> <span style="color: #0000ff;">long</span>);</pre>
<!--CRLF-->
<pre><span id="lnum7" style="color: #606060;">   7:</span>&nbsp; </pre>
<!--CRLF-->
<pre><span id="lnum8" style="color: #606060;">   8:</span>     <span style="color: #0000ff;">unsigned</span> <span style="color: #0000ff;">long</span> error = arch_mmap_check(addr, len, flags);</pre>
<!--CRLF-->
<pre><span id="lnum9" style="color: #606060;">   9:</span>     <span style="color: #0000ff;">if</span> (error)</pre>
<!--CRLF-->
<pre><span id="lnum10" style="color: #606060;">  10:</span>         <span style="color: #0000ff;">return</span> error;</pre>
<!--CRLF-->
<pre><span id="lnum11" style="color: #606060;">  11:</span>&nbsp; </pre>
<!--CRLF-->
<pre><span id="lnum12" style="color: #606060;">  12:</span>     <span style="color: #008000;">/* Careful about overflows.. */</span></pre>
<!--CRLF-->
<pre><span id="lnum13" style="color: #606060;">  13:</span>     <span style="color: #0000ff;">if</span> (len &gt; TASK_SIZE)</pre>
<!--CRLF-->
<pre><span id="lnum14" style="color: #606060;">  14:</span>         <span style="color: #0000ff;">return</span> -ENOMEM;</pre>
<!--CRLF-->
<pre><span id="lnum15" style="color: #606060;">  15:</span>&nbsp; </pre>
<!--CRLF-->
<pre><span id="lnum16" style="color: #606060;">  16:</span>     get_area = current-&gt;mm-&gt;get_unmapped_area;</pre>
<!--CRLF-->
<pre><span id="lnum17" style="color: #606060;">  17:</span>     <span style="color: #0000ff;">if</span> (file &amp;&amp; file-&gt;f_op &amp;&amp; file-&gt;f_op-&gt;get_unmapped_area)</pre>
<!--CRLF-->
<pre><span id="lnum18" style="color: #606060;">  18:</span>         get_area = file-&gt;f_op-&gt;get_unmapped_area;</pre>
<!--CRLF-->
<pre><span id="lnum19" style="color: #606060;">  19:</span>     addr = get_area(file, addr, len, pgoff, flags);</pre>
<!--CRLF-->
<pre><span id="lnum20" style="color: #606060;">  20:</span>     <span style="color: #0000ff;">if</span> (IS_ERR_VALUE(addr))</pre>
<!--CRLF-->
<pre><span id="lnum21" style="color: #606060;">  21:</span>         <span style="color: #0000ff;">return</span> addr;</pre>
<!--CRLF-->
<pre><span id="lnum22" style="color: #606060;">  22:</span>&nbsp; </pre>
<!--CRLF-->
<pre><span id="lnum23" style="color: #606060;">  23:</span>     <span style="color: #0000ff;">if</span> (addr &gt; TASK_SIZE - len)</pre>
<!--CRLF-->
<pre><span id="lnum24" style="color: #606060;">  24:</span>         <span style="color: #0000ff;">return</span> -ENOMEM;</pre>
<!--CRLF-->
<pre><span id="lnum25" style="color: #606060;">  25:</span>     <span style="color: #0000ff;">if</span> (addr &amp; ~PAGE_MASK)</pre>
<!--CRLF-->
<pre><span id="lnum26" style="color: #606060;">  26:</span>         <span style="color: #0000ff;">return</span> -EINVAL;</pre>
<!--CRLF-->
<pre><span id="lnum27" style="color: #606060;">  27:</span>&nbsp; </pre>
<!--CRLF-->
<pre><span id="lnum28" style="color: #606060;">  28:</span>     <span style="color: #0000ff;">return</span> arch_rebalance_pgtables(addr, len);</pre>
<!--CRLF-->
<pre><span id="lnum29" style="color: #606060;">  29:</span> }</pre>
<!--CRLF--></div>
</div>
<p>insert_vm_struct，把一个指定的内存区间，添加到指定的内存描述符中</p>
<div id="codeSnippetWrapper" style="text-align: left; line-height: 12pt; background-color: #f4f4f4; margin: 20px 0px 10px; width: 97.5%; font-family: 'Courier New', courier, monospace; direction: ltr; max-height: 200px; font-size: 8pt; overflow: auto; cursor: text; border: silver 1px solid; padding: 4px;">
<div id="codeSnippet" style="text-align: left; line-height: 12pt; background-color: #f4f4f4; width: 100%; font-family: 'Courier New', courier, monospace; direction: ltr; color: black; font-size: 8pt; overflow: visible; border-style: none; padding: 0px;">
<pre><span id="lnum1" style="color: #606060;">   1:</span> <span style="color: #008000;">/* Insert vm structure into process list sorted by address</span></pre>
<!--CRLF-->
<pre><span id="lnum2" style="color: #606060;">   2:</span> <span style="color: #008000;"> * and into the inode's i_mmap tree.  If vm_file is non-NULL</span></pre>
<!--CRLF-->
<pre><span id="lnum3" style="color: #606060;">   3:</span> <span style="color: #008000;"> * then i_mmap_mutex is taken here.</span></pre>
<!--CRLF-->
<pre><span id="lnum4" style="color: #606060;">   4:</span> <span style="color: #008000;"> */</span></pre>
<!--CRLF-->
<pre><span id="lnum5" style="color: #606060;">   5:</span> <span style="color: #0000ff;">int</span> insert_vm_struct(<span style="color: #0000ff;">struct</span> mm_struct * mm, <span style="color: #0000ff;">struct</span> vm_area_struct * vma)</pre>
<!--CRLF-->
<pre><span id="lnum6" style="color: #606060;">   6:</span> {</pre>
<!--CRLF-->
<pre><span id="lnum7" style="color: #606060;">   7:</span>     <span style="color: #0000ff;">struct</span> vm_area_struct * __vma, * prev;</pre>
<!--CRLF-->
<pre><span id="lnum8" style="color: #606060;">   8:</span>     <span style="color: #0000ff;">struct</span> rb_node ** rb_link, * rb_parent;</pre>
<!--CRLF-->
<pre><span id="lnum9" style="color: #606060;">   9:</span>&nbsp; </pre>
<!--CRLF-->
<pre><span id="lnum10" style="color: #606060;">  10:</span>     <span style="color: #008000;">/*</span></pre>
<!--CRLF-->
<pre><span id="lnum11" style="color: #606060;">  11:</span> <span style="color: #008000;">     * The vm_pgoff of a purely anonymous vma should be irrelevant</span></pre>
<!--CRLF-->
<pre><span id="lnum12" style="color: #606060;">  12:</span> <span style="color: #008000;">     * until its first write fault, when page's anon_vma and index</span></pre>
<!--CRLF-->
<pre><span id="lnum13" style="color: #606060;">  13:</span> <span style="color: #008000;">     * are set.  But now set the vm_pgoff it will almost certainly</span></pre>
<!--CRLF-->
<pre><span id="lnum14" style="color: #606060;">  14:</span> <span style="color: #008000;">     * end up with (unless mremap moves it elsewhere before that</span></pre>
<!--CRLF-->
<pre><span id="lnum15" style="color: #606060;">  15:</span> <span style="color: #008000;">     * first wfault), so /proc/pid/maps tells a consistent story.</span></pre>
<!--CRLF-->
<pre><span id="lnum16" style="color: #606060;">  16:</span> <span style="color: #008000;">     *</span></pre>
<!--CRLF-->
<pre><span id="lnum17" style="color: #606060;">  17:</span> <span style="color: #008000;">     * By setting it to reflect the virtual start address of the</span></pre>
<!--CRLF-->
<pre><span id="lnum18" style="color: #606060;">  18:</span> <span style="color: #008000;">     * vma, merges and splits can happen in a seamless way, just</span></pre>
<!--CRLF-->
<pre><span id="lnum19" style="color: #606060;">  19:</span> <span style="color: #008000;">     * using the existing file pgoff checks and manipulations.</span></pre>
<!--CRLF-->
<pre><span id="lnum20" style="color: #606060;">  20:</span> <span style="color: #008000;">     * Similarly in do_mmap_pgoff and in do_brk.</span></pre>
<!--CRLF-->
<pre><span id="lnum21" style="color: #606060;">  21:</span> <span style="color: #008000;">     */</span></pre>
<!--CRLF-->
<pre><span id="lnum22" style="color: #606060;">  22:</span>     <span style="color: #0000ff;">if</span> (!vma-&gt;vm_file) {</pre>
<!--CRLF-->
<pre><span id="lnum23" style="color: #606060;">  23:</span>         BUG_ON(vma-&gt;anon_vma);</pre>
<!--CRLF-->
<pre><span id="lnum24" style="color: #606060;">  24:</span>         vma-&gt;vm_pgoff = vma-&gt;vm_start &gt;&gt; PAGE_SHIFT;</pre>
<!--CRLF-->
<pre><span id="lnum25" style="color: #606060;">  25:</span>     }</pre>
<!--CRLF-->
<pre><span id="lnum26" style="color: #606060;">  26:</span>     __vma = find_vma_prepare(mm,vma-&gt;vm_start,&amp;prev,&amp;rb_link,&amp;rb_parent);</pre>
<!--CRLF-->
<pre><span id="lnum27" style="color: #606060;">  27:</span>     <span style="color: #0000ff;">if</span> (__vma &amp;&amp; __vma-&gt;vm_start &lt; vma-&gt;vm_end)</pre>
<!--CRLF-->
<pre><span id="lnum28" style="color: #606060;">  28:</span>         <span style="color: #0000ff;">return</span> -ENOMEM;</pre>
<!--CRLF-->
<pre><span id="lnum29" style="color: #606060;">  29:</span>     <span style="color: #0000ff;">if</span> ((vma-&gt;vm_flags &amp; VM_ACCOUNT) &amp;&amp;</pre>
<!--CRLF-->
<pre><span id="lnum30" style="color: #606060;">  30:</span>          security_vm_enough_memory_mm(mm, vma_pages(vma)))</pre>
<!--CRLF-->
<pre><span id="lnum31" style="color: #606060;">  31:</span>         <span style="color: #0000ff;">return</span> -ENOMEM;</pre>
<!--CRLF-->
<pre><span id="lnum32" style="color: #606060;">  32:</span>     vma_link(mm, vma, prev, rb_link, rb_parent);</pre>
<!--CRLF-->
<pre><span id="lnum33" style="color: #606060;">  33:</span>     <span style="color: #0000ff;">return</span> 0;</pre>
<!--CRLF-->
<pre><span id="lnum34" style="color: #606060;">  34:</span> }</pre>
<!--CRLF--></div>
</div>
<p>do_mmap， 分配一个线性地址内存区间，实现中调用do_mmap_pgoff和mmap_region完成。</p>
<blockquote>
<p>/*<br />* 'kernel.h' contains some often-used function prototypes etc<br />*/<br />#define __ALIGN_KERNEL(x, a)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; __ALIGN_KERNEL_MASK(x, (typeof(x))(a) - 1)<br />#define __ALIGN_KERNEL_MASK(x, mask)&nbsp;&nbsp;&nbsp; (((x) + (mask)) &amp; ~(mask))</p>
</blockquote>
<div id="codeSnippetWrapper" style="text-align: left; line-height: 12pt; background-color: #f4f4f4; margin: 20px 0px 10px; width: 97.5%; font-family: 'Courier New', courier, monospace; direction: ltr; max-height: 200px; font-size: 8pt; overflow: auto; cursor: text; border: silver 1px solid; padding: 4px;">
<div id="codeSnippet" style="text-align: left; line-height: 12pt; background-color: #f4f4f4; width: 100%; font-family: 'Courier New', courier, monospace; direction: ltr; color: black; font-size: 8pt; overflow: visible; border-style: none; padding: 0px;">
<pre><span id="lnum1" style="color: #606060;">   1:</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">inline</span> <span style="color: #0000ff;">unsigned</span> <span style="color: #0000ff;">long</span> do_mmap(<span style="color: #0000ff;">struct</span> file *file, <span style="color: #0000ff;">unsigned</span> <span style="color: #0000ff;">long</span> addr,</pre>
<!--CRLF-->
<pre><span id="lnum2" style="color: #606060;">   2:</span>     <span style="color: #0000ff;">unsigned</span> <span style="color: #0000ff;">long</span> len, <span style="color: #0000ff;">unsigned</span> <span style="color: #0000ff;">long</span> prot,</pre>
<!--CRLF-->
<pre><span id="lnum3" style="color: #606060;">   3:</span>     <span style="color: #0000ff;">unsigned</span> <span style="color: #0000ff;">long</span> flag, <span style="color: #0000ff;">unsigned</span> <span style="color: #0000ff;">long</span> offset)</pre>
<!--CRLF-->
<pre><span id="lnum4" style="color: #606060;">   4:</span> {</pre>
<!--CRLF-->
<pre><span id="lnum5" style="color: #606060;">   5:</span>     <span style="color: #0000ff;">unsigned</span> <span style="color: #0000ff;">long</span> ret = -EINVAL;</pre>
<!--CRLF-->
<pre><span id="lnum6" style="color: #606060;">   6:</span>     <span style="color: #0000ff;">if</span> ((offset + PAGE_ALIGN(len)) &lt; offset)</pre>
<!--CRLF-->
<pre><span id="lnum7" style="color: #606060;">   7:</span>         <span style="color: #0000ff;">goto</span> out;</pre>
<!--CRLF-->
<pre><span id="lnum8" style="color: #606060;">   8:</span>     <span style="color: #0000ff;">if</span> (!(offset &amp; ~PAGE_MASK))</pre>
<!--CRLF-->
<pre><span id="lnum9" style="color: #606060;">   9:</span>         ret = do_mmap_pgoff(file, addr, len, prot, flag, offset &gt;&gt; PAGE_SHIFT);</pre>
<!--CRLF-->
<pre><span id="lnum10" style="color: #606060;">  10:</span> out:</pre>
<!--CRLF-->
<pre><span id="lnum11" style="color: #606060;">  11:</span>     <span style="color: #0000ff;">return</span> ret;</pre>
<!--CRLF-->
<pre><span id="lnum12" style="color: #606060;">  12:</span> }</pre>
<!--CRLF-->
<pre><span id="lnum13" style="color: #606060;">  13:</span>&nbsp; </pre>
<!--CRLF-->
<pre><span id="lnum14" style="color: #606060;">  14:</span> <span style="color: #008000;">/*</span></pre>
<!--CRLF-->
<pre><span id="lnum15" style="color: #606060;">  15:</span> <span style="color: #008000;"> * The caller must hold down_write(&amp;current-&gt;mm-&gt;mmap_sem).</span></pre>
<!--CRLF-->
<pre><span id="lnum16" style="color: #606060;">  16:</span> <span style="color: #008000;"> */</span></pre>
<!--CRLF-->
<pre><span id="lnum17" style="color: #606060;">  17:</span>&nbsp; </pre>
<!--CRLF-->
<pre><span id="lnum18" style="color: #606060;">  18:</span> <span style="color: #0000ff;">unsigned</span> <span style="color: #0000ff;">long</span> do_mmap_pgoff(<span style="color: #0000ff;">struct</span> file *file, <span style="color: #0000ff;">unsigned</span> <span style="color: #0000ff;">long</span> addr,</pre>
<!--CRLF-->
<pre><span id="lnum19" style="color: #606060;">  19:</span>             <span style="color: #0000ff;">unsigned</span> <span style="color: #0000ff;">long</span> len, <span style="color: #0000ff;">unsigned</span> <span style="color: #0000ff;">long</span> prot,</pre>
<!--CRLF-->
<pre><span id="lnum20" style="color: #606060;">  20:</span>             <span style="color: #0000ff;">unsigned</span> <span style="color: #0000ff;">long</span> flags, <span style="color: #0000ff;">unsigned</span> <span style="color: #0000ff;">long</span> pgoff)</pre>
<!--CRLF-->
<pre><span id="lnum21" style="color: #606060;">  21:</span> {</pre>
<!--CRLF-->
<pre><span id="lnum22" style="color: #606060;">  22:</span>     <span style="color: #0000ff;">struct</span> mm_struct * mm = current-&gt;mm;</pre>
<!--CRLF-->
<pre><span id="lnum23" style="color: #606060;">  23:</span>     <span style="color: #0000ff;">struct</span> inode *inode;</pre>
<!--CRLF-->
<pre><span id="lnum24" style="color: #606060;">  24:</span>     vm_flags_t vm_flags;</pre>
<!--CRLF-->
<pre><span id="lnum25" style="color: #606060;">  25:</span>     <span style="color: #0000ff;">int</span> error;</pre>
<!--CRLF-->
<pre><span id="lnum26" style="color: #606060;">  26:</span>     <span style="color: #0000ff;">unsigned</span> <span style="color: #0000ff;">long</span> reqprot = prot;</pre>
<!--CRLF-->
<pre><span id="lnum27" style="color: #606060;">  27:</span>&nbsp; </pre>
<!--CRLF-->
<pre><span id="lnum28" style="color: #606060;">  28:</span>     <span style="color: #008000;">/*</span></pre>
<!--CRLF-->
<pre><span id="lnum29" style="color: #606060;">  29:</span> <span style="color: #008000;">     * Does the application expect PROT_READ to imply PROT_EXEC?</span></pre>
<!--CRLF-->
<pre><span id="lnum30" style="color: #606060;">  30:</span> <span style="color: #008000;">     *</span></pre>
<!--CRLF-->
<pre><span id="lnum31" style="color: #606060;">  31:</span> <span style="color: #008000;">     * (the exception is when the underlying filesystem is noexec</span></pre>
<!--CRLF-->
<pre><span id="lnum32" style="color: #606060;">  32:</span> <span style="color: #008000;">     *  mounted, in which case we dont add PROT_EXEC.)</span></pre>
<!--CRLF-->
<pre><span id="lnum33" style="color: #606060;">  33:</span> <span style="color: #008000;">     */</span></pre>
<!--CRLF-->
<pre><span id="lnum34" style="color: #606060;">  34:</span>     <span style="color: #0000ff;">if</span> ((prot &amp; PROT_READ) &amp;&amp; (current-&gt;personality &amp; READ_IMPLIES_EXEC))</pre>
<!--CRLF-->
<pre><span id="lnum35" style="color: #606060;">  35:</span>         <span style="color: #0000ff;">if</span> (!(file &amp;&amp; (file-&gt;f_path.mnt-&gt;mnt_flags &amp; MNT_NOEXEC)))</pre>
<!--CRLF-->
<pre><span id="lnum36" style="color: #606060;">  36:</span>             prot |= PROT_EXEC;</pre>
<!--CRLF-->
<pre><span id="lnum37" style="color: #606060;">  37:</span>&nbsp; </pre>
<!--CRLF-->
<pre><span id="lnum38" style="color: #606060;">  38:</span>     <span style="color: #0000ff;">if</span> (!len)</pre>
<!--CRLF-->
<pre><span id="lnum39" style="color: #606060;">  39:</span>         <span style="color: #0000ff;">return</span> -EINVAL;</pre>
<!--CRLF-->
<pre><span id="lnum40" style="color: #606060;">  40:</span>&nbsp; </pre>
<!--CRLF-->
<pre><span id="lnum41" style="color: #606060;">  41:</span>     <span style="color: #0000ff;">if</span> (!(flags &amp; MAP_FIXED))</pre>
<!--CRLF-->
<pre><span id="lnum42" style="color: #606060;">  42:</span>         addr = round_hint_to_min(addr);</pre>
<!--CRLF-->
<pre><span id="lnum43" style="color: #606060;">  43:</span>&nbsp; </pre>
<!--CRLF-->
<pre><span id="lnum44" style="color: #606060;">  44:</span>     <span style="color: #008000;">/* Careful about overflows.. */</span></pre>
<!--CRLF-->
<pre><span id="lnum45" style="color: #606060;">  45:</span>     len = PAGE_ALIGN(len);</pre>
<!--CRLF-->
<pre><span id="lnum46" style="color: #606060;">  46:</span>     <span style="color: #0000ff;">if</span> (!len)</pre>
<!--CRLF-->
<pre><span id="lnum47" style="color: #606060;">  47:</span>         <span style="color: #0000ff;">return</span> -ENOMEM;</pre>
<!--CRLF-->
<pre><span id="lnum48" style="color: #606060;">  48:</span>&nbsp; </pre>
<!--CRLF-->
<pre><span id="lnum49" style="color: #606060;">  49:</span>     <span style="color: #008000;">/* offset overflow? */</span></pre>
<!--CRLF-->
<pre><span id="lnum50" style="color: #606060;">  50:</span>     <span style="color: #0000ff;">if</span> ((pgoff + (len &gt;&gt; PAGE_SHIFT)) &lt; pgoff)</pre>
<!--CRLF-->
<pre><span id="lnum51" style="color: #606060;">  51:</span>                <span style="color: #0000ff;">return</span> -EOVERFLOW;</pre>
<!--CRLF-->
<pre><span id="lnum52" style="color: #606060;">  52:</span>&nbsp; </pre>
<!--CRLF-->
<pre><span id="lnum53" style="color: #606060;">  53:</span>     <span style="color: #008000;">/* Too many mappings? */</span></pre>
<!--CRLF-->
<pre><span id="lnum54" style="color: #606060;">  54:</span>     <span style="color: #0000ff;">if</span> (mm-&gt;map_count &gt; sysctl_max_map_count)</pre>
<!--CRLF-->
<pre><span id="lnum55" style="color: #606060;">  55:</span>         <span style="color: #0000ff;">return</span> -ENOMEM;</pre>
<!--CRLF-->
<pre><span id="lnum56" style="color: #606060;">  56:</span>&nbsp; </pre>
<!--CRLF-->
<pre><span id="lnum57" style="color: #606060;">  57:</span>     <span style="color: #008000;">/* Obtain the address to map to. we verify (or select) it and ensure</span></pre>
<!--CRLF-->
<pre><span id="lnum58" style="color: #606060;">  58:</span> <span style="color: #008000;">     * that it represents a valid section of the address space.</span></pre>
<!--CRLF-->
<pre><span id="lnum59" style="color: #606060;">  59:</span> <span style="color: #008000;">     */</span></pre>
<!--CRLF-->
<pre><span id="lnum60" style="color: #606060;">  60:</span>     addr = get_unmapped_area(file, addr, len, pgoff, flags);</pre>
<!--CRLF-->
<pre><span id="lnum61" style="color: #606060;">  61:</span>     <span style="color: #0000ff;">if</span> (addr &amp; ~PAGE_MASK)</pre>
<!--CRLF-->
<pre><span id="lnum62" style="color: #606060;">  62:</span>         <span style="color: #0000ff;">return</span> addr;</pre>
<!--CRLF-->
<pre><span id="lnum63" style="color: #606060;">  63:</span>&nbsp; </pre>
<!--CRLF-->
<pre><span id="lnum64" style="color: #606060;">  64:</span>     <span style="color: #008000;">/* Do simple checking here so the lower-level routines won't have</span></pre>
<!--CRLF-->
<pre><span id="lnum65" style="color: #606060;">  65:</span> <span style="color: #008000;">     * to. we assume access permissions have been handled by the open</span></pre>
<!--CRLF-->
<pre><span id="lnum66" style="color: #606060;">  66:</span> <span style="color: #008000;">     * of the memory object, so we don't do any here.</span></pre>
<!--CRLF-->
<pre><span id="lnum67" style="color: #606060;">  67:</span> <span style="color: #008000;">     */</span></pre>
<!--CRLF-->
<pre><span id="lnum68" style="color: #606060;">  68:</span>     vm_flags = calc_vm_prot_bits(prot) | calc_vm_flag_bits(flags) |</pre>
<!--CRLF-->
<pre><span id="lnum69" style="color: #606060;">  69:</span>             mm-&gt;def_flags | VM_MAYREAD | VM_MAYWRITE | VM_MAYEXEC;</pre>
<!--CRLF-->
<pre><span id="lnum70" style="color: #606060;">  70:</span>&nbsp; </pre>
<!--CRLF-->
<pre><span id="lnum71" style="color: #606060;">  71:</span>     <span style="color: #0000ff;">if</span> (flags &amp; MAP_LOCKED)</pre>
<!--CRLF-->
<pre><span id="lnum72" style="color: #606060;">  72:</span>         <span style="color: #0000ff;">if</span> (!can_do_mlock())</pre>
<!--CRLF-->
<pre><span id="lnum73" style="color: #606060;">  73:</span>             <span style="color: #0000ff;">return</span> -EPERM;</pre>
<!--CRLF-->
<pre><span id="lnum74" style="color: #606060;">  74:</span>&nbsp; </pre>
<!--CRLF-->
<pre><span id="lnum75" style="color: #606060;">  75:</span>     <span style="color: #008000;">/* mlock MCL_FUTURE? */</span></pre>
<!--CRLF-->
<pre><span id="lnum76" style="color: #606060;">  76:</span>     <span style="color: #0000ff;">if</span> (vm_flags &amp; VM_LOCKED) {</pre>
<!--CRLF-->
<pre><span id="lnum77" style="color: #606060;">  77:</span>         <span style="color: #0000ff;">unsigned</span> <span style="color: #0000ff;">long</span> locked, lock_limit;</pre>
<!--CRLF-->
<pre><span id="lnum78" style="color: #606060;">  78:</span>         locked = len &gt;&gt; PAGE_SHIFT;</pre>
<!--CRLF-->
<pre><span id="lnum79" style="color: #606060;">  79:</span>         locked += mm-&gt;locked_vm;</pre>
<!--CRLF-->
<pre><span id="lnum80" style="color: #606060;">  80:</span>         lock_limit = rlimit(RLIMIT_MEMLOCK);</pre>
<!--CRLF-->
<pre><span id="lnum81" style="color: #606060;">  81:</span>         lock_limit &gt;&gt;= PAGE_SHIFT;</pre>
<!--CRLF-->
<pre><span id="lnum82" style="color: #606060;">  82:</span>         <span style="color: #0000ff;">if</span> (locked &gt; lock_limit &amp;&amp; !capable(CAP_IPC_LOCK))</pre>
<!--CRLF-->
<pre><span id="lnum83" style="color: #606060;">  83:</span>             <span style="color: #0000ff;">return</span> -EAGAIN;</pre>
<!--CRLF-->
<pre><span id="lnum84" style="color: #606060;">  84:</span>     }</pre>
<!--CRLF-->
<pre><span id="lnum85" style="color: #606060;">  85:</span>&nbsp; </pre>
<!--CRLF-->
<pre><span id="lnum86" style="color: #606060;">  86:</span>     inode = file ? file-&gt;f_path.dentry-&gt;d_inode : NULL;</pre>
<!--CRLF-->
<pre><span id="lnum87" style="color: #606060;">  87:</span>&nbsp; </pre>
<!--CRLF-->
<pre><span id="lnum88" style="color: #606060;">  88:</span>     <span style="color: #0000ff;">if</span> (file) {</pre>
<!--CRLF-->
<pre><span id="lnum89" style="color: #606060;">  89:</span>         <span style="color: #0000ff;">switch</span> (flags &amp; MAP_TYPE) {</pre>
<!--CRLF-->
<pre><span id="lnum90" style="color: #606060;">  90:</span>         <span style="color: #0000ff;">case</span> MAP_SHARED:</pre>
<!--CRLF-->
<pre><span id="lnum91" style="color: #606060;">  91:</span>             <span style="color: #0000ff;">if</span> ((prot&amp;PROT_WRITE) &amp;&amp; !(file-&gt;f_mode&amp;FMODE_WRITE))</pre>
<!--CRLF-->
<pre><span id="lnum92" style="color: #606060;">  92:</span>                 <span style="color: #0000ff;">return</span> -EACCES;</pre>
<!--CRLF-->
<pre><span id="lnum93" style="color: #606060;">  93:</span>&nbsp; </pre>
<!--CRLF-->
<pre><span id="lnum94" style="color: #606060;">  94:</span>             <span style="color: #008000;">/*</span></pre>
<!--CRLF-->
<pre><span id="lnum95" style="color: #606060;">  95:</span> <span style="color: #008000;">             * Make sure we don't allow writing to an append-only</span></pre>
<!--CRLF-->
<pre><span id="lnum96" style="color: #606060;">  96:</span> <span style="color: #008000;">             * file..</span></pre>
<!--CRLF-->
<pre><span id="lnum97" style="color: #606060;">  97:</span> <span style="color: #008000;">             */</span></pre>
<!--CRLF-->
<pre><span id="lnum98" style="color: #606060;">  98:</span>             <span style="color: #0000ff;">if</span> (IS_APPEND(inode) &amp;&amp; (file-&gt;f_mode &amp; FMODE_WRITE))</pre>
<!--CRLF-->
<pre><span id="lnum99" style="color: #606060;">  99:</span>                 <span style="color: #0000ff;">return</span> -EACCES;</pre>
<!--CRLF-->
<pre><span id="lnum100" style="color: #606060;"> 100:</span>&nbsp; </pre>
<!--CRLF-->
<pre><span id="lnum101" style="color: #606060;"> 101:</span>             <span style="color: #008000;">/*</span></pre>
<!--CRLF-->
<pre><span id="lnum102" style="color: #606060;"> 102:</span> <span style="color: #008000;">             * Make sure there are no mandatory locks on the file.</span></pre>
<!--CRLF-->
<pre><span id="lnum103" style="color: #606060;"> 103:</span> <span style="color: #008000;">             */</span></pre>
<!--CRLF-->
<pre><span id="lnum104" style="color: #606060;"> 104:</span>             <span style="color: #0000ff;">if</span> (locks_verify_locked(inode))</pre>
<!--CRLF-->
<pre><span id="lnum105" style="color: #606060;"> 105:</span>                 <span style="color: #0000ff;">return</span> -EAGAIN;</pre>
<!--CRLF-->
<pre><span id="lnum106" style="color: #606060;"> 106:</span>&nbsp; </pre>
<!--CRLF-->
<pre><span id="lnum107" style="color: #606060;"> 107:</span>             vm_flags |= VM_SHARED | VM_MAYSHARE;</pre>
<!--CRLF-->
<pre><span id="lnum108" style="color: #606060;"> 108:</span>             <span style="color: #0000ff;">if</span> (!(file-&gt;f_mode &amp; FMODE_WRITE))</pre>
<!--CRLF-->
<pre><span id="lnum109" style="color: #606060;"> 109:</span>                 vm_flags &amp;= ~(VM_MAYWRITE | VM_SHARED);</pre>
<!--CRLF-->
<pre><span id="lnum110" style="color: #606060;"> 110:</span>&nbsp; </pre>
<!--CRLF-->
<pre><span id="lnum111" style="color: #606060;"> 111:</span>             <span style="color: #008000;">/* fall through */</span></pre>
<!--CRLF-->
<pre><span id="lnum112" style="color: #606060;"> 112:</span>         <span style="color: #0000ff;">case</span> MAP_PRIVATE:</pre>
<!--CRLF-->
<pre><span id="lnum113" style="color: #606060;"> 113:</span>             <span style="color: #0000ff;">if</span> (!(file-&gt;f_mode &amp; FMODE_READ))</pre>
<!--CRLF-->
<pre><span id="lnum114" style="color: #606060;"> 114:</span>                 <span style="color: #0000ff;">return</span> -EACCES;</pre>
<!--CRLF-->
<pre><span id="lnum115" style="color: #606060;"> 115:</span>             <span style="color: #0000ff;">if</span> (file-&gt;f_path.mnt-&gt;mnt_flags &amp; MNT_NOEXEC) {</pre>
<!--CRLF-->
<pre><span id="lnum116" style="color: #606060;"> 116:</span>                 <span style="color: #0000ff;">if</span> (vm_flags &amp; VM_EXEC)</pre>
<!--CRLF-->
<pre><span id="lnum117" style="color: #606060;"> 117:</span>                     <span style="color: #0000ff;">return</span> -EPERM;</pre>
<!--CRLF-->
<pre><span id="lnum118" style="color: #606060;"> 118:</span>                 vm_flags &amp;= ~VM_MAYEXEC;</pre>
<!--CRLF-->
<pre><span id="lnum119" style="color: #606060;"> 119:</span>             }</pre>
<!--CRLF-->
<pre><span id="lnum120" style="color: #606060;"> 120:</span>&nbsp; </pre>
<!--CRLF-->
<pre><span id="lnum121" style="color: #606060;"> 121:</span>             <span style="color: #0000ff;">if</span> (!file-&gt;f_op || !file-&gt;f_op-&gt;mmap)</pre>
<!--CRLF-->
<pre><span id="lnum122" style="color: #606060;"> 122:</span>                 <span style="color: #0000ff;">return</span> -ENODEV;</pre>
<!--CRLF-->
<pre><span id="lnum123" style="color: #606060;"> 123:</span>             <span style="color: #0000ff;">break</span>;</pre>
<!--CRLF-->
<pre><span id="lnum124" style="color: #606060;"> 124:</span>&nbsp; </pre>
<!--CRLF-->
<pre><span id="lnum125" style="color: #606060;"> 125:</span>         <span style="color: #0000ff;">default</span>:</pre>
<!--CRLF-->
<pre><span id="lnum126" style="color: #606060;"> 126:</span>             <span style="color: #0000ff;">return</span> -EINVAL;</pre>
<!--CRLF-->
<pre><span id="lnum127" style="color: #606060;"> 127:</span>         }</pre>
<!--CRLF-->
<pre><span id="lnum128" style="color: #606060;"> 128:</span>     } <span style="color: #0000ff;">else</span> {</pre>
<!--CRLF-->
<pre><span id="lnum129" style="color: #606060;"> 129:</span>         <span style="color: #0000ff;">switch</span> (flags &amp; MAP_TYPE) {</pre>
<!--CRLF-->
<pre><span id="lnum130" style="color: #606060;"> 130:</span>         <span style="color: #0000ff;">case</span> MAP_SHARED:</pre>
<!--CRLF-->
<pre><span id="lnum131" style="color: #606060;"> 131:</span>             <span style="color: #008000;">/*</span></pre>
<!--CRLF-->
<pre><span id="lnum132" style="color: #606060;"> 132:</span> <span style="color: #008000;">             * Ignore pgoff.</span></pre>
<!--CRLF-->
<pre><span id="lnum133" style="color: #606060;"> 133:</span> <span style="color: #008000;">             */</span></pre>
<!--CRLF-->
<pre><span id="lnum134" style="color: #606060;"> 134:</span>             pgoff = 0;</pre>
<!--CRLF-->
<pre><span id="lnum135" style="color: #606060;"> 135:</span>             vm_flags |= VM_SHARED | VM_MAYSHARE;</pre>
<!--CRLF-->
<pre><span id="lnum136" style="color: #606060;"> 136:</span>             <span style="color: #0000ff;">break</span>;</pre>
<!--CRLF-->
<pre><span id="lnum137" style="color: #606060;"> 137:</span>         <span style="color: #0000ff;">case</span> MAP_PRIVATE:</pre>
<!--CRLF-->
<pre><span id="lnum138" style="color: #606060;"> 138:</span>             <span style="color: #008000;">/*</span></pre>
<!--CRLF-->
<pre><span id="lnum139" style="color: #606060;"> 139:</span> <span style="color: #008000;">             * Set pgoff according to addr for anon_vma.</span></pre>
<!--CRLF-->
<pre><span id="lnum140" style="color: #606060;"> 140:</span> <span style="color: #008000;">             */</span></pre>
<!--CRLF-->
<pre><span id="lnum141" style="color: #606060;"> 141:</span>             pgoff = addr &gt;&gt; PAGE_SHIFT;</pre>
<!--CRLF-->
<pre><span id="lnum142" style="color: #606060;"> 142:</span>             <span style="color: #0000ff;">break</span>;</pre>
<!--CRLF-->
<pre><span id="lnum143" style="color: #606060;"> 143:</span>         <span style="color: #0000ff;">default</span>:</pre>
<!--CRLF-->
<pre><span id="lnum144" style="color: #606060;"> 144:</span>             <span style="color: #0000ff;">return</span> -EINVAL;</pre>
<!--CRLF-->
<pre><span id="lnum145" style="color: #606060;"> 145:</span>         }</pre>
<!--CRLF-->
<pre><span id="lnum146" style="color: #606060;"> 146:</span>     }</pre>
<!--CRLF-->
<pre><span id="lnum147" style="color: #606060;"> 147:</span>&nbsp; </pre>
<!--CRLF-->
<pre><span id="lnum148" style="color: #606060;"> 148:</span>     error = security_file_mmap(file, reqprot, prot, flags, addr, 0);</pre>
<!--CRLF-->
<pre><span id="lnum149" style="color: #606060;"> 149:</span>     <span style="color: #0000ff;">if</span> (error)</pre>
<!--CRLF-->
<pre><span id="lnum150" style="color: #606060;"> 150:</span>         <span style="color: #0000ff;">return</span> error;</pre>
<!--CRLF-->
<pre><span id="lnum151" style="color: #606060;"> 151:</span>&nbsp; </pre>
<!--CRLF-->
<pre><span id="lnum152" style="color: #606060;"> 152:</span>     <span style="color: #0000ff;">return</span> mmap_region(file, addr, len, flags, vm_flags, pgoff);</pre>
<!--CRLF-->
<pre><span id="lnum153" style="color: #606060;"> 153:</span> }</pre>
<!--CRLF-->
<pre><span id="lnum154" style="color: #606060;"> 154:</span> EXPORT_SYMBOL(do_mmap_pgoff);</pre>
<!--CRLF-->
<pre><span id="lnum155" style="color: #606060;"> 155:</span>&nbsp; </pre>
<!--CRLF-->
<pre><span id="lnum156" style="color: #606060;"> 156:</span> <span style="color: #0000ff;">unsigned</span> <span style="color: #0000ff;">long</span> mmap_region(<span style="color: #0000ff;">struct</span> file *file, <span style="color: #0000ff;">unsigned</span> <span style="color: #0000ff;">long</span> addr,</pre>
<!--CRLF-->
<pre><span id="lnum157" style="color: #606060;"> 157:</span>               <span style="color: #0000ff;">unsigned</span> <span style="color: #0000ff;">long</span> len, <span style="color: #0000ff;">unsigned</span> <span style="color: #0000ff;">long</span> flags,</pre>
<!--CRLF-->
<pre><span id="lnum158" style="color: #606060;"> 158:</span>               vm_flags_t vm_flags, <span style="color: #0000ff;">unsigned</span> <span style="color: #0000ff;">long</span> pgoff)</pre>
<!--CRLF-->
<pre><span id="lnum159" style="color: #606060;"> 159:</span> {</pre>
<!--CRLF-->
<pre><span id="lnum160" style="color: #606060;"> 160:</span>     <span style="color: #0000ff;">struct</span> mm_struct *mm = current-&gt;mm;</pre>
<!--CRLF-->
<pre><span id="lnum161" style="color: #606060;"> 161:</span>     <span style="color: #0000ff;">struct</span> vm_area_struct *vma, *prev;</pre>
<!--CRLF-->
<pre><span id="lnum162" style="color: #606060;"> 162:</span>     <span style="color: #0000ff;">int</span> correct_wcount = 0;</pre>
<!--CRLF-->
<pre><span id="lnum163" style="color: #606060;"> 163:</span>     <span style="color: #0000ff;">int</span> error;</pre>
<!--CRLF-->
<pre><span id="lnum164" style="color: #606060;"> 164:</span>     <span style="color: #0000ff;">struct</span> rb_node **rb_link, *rb_parent;</pre>
<!--CRLF-->
<pre><span id="lnum165" style="color: #606060;"> 165:</span>     <span style="color: #0000ff;">unsigned</span> <span style="color: #0000ff;">long</span> charged = 0;</pre>
<!--CRLF-->
<pre><span id="lnum166" style="color: #606060;"> 166:</span>     <span style="color: #0000ff;">struct</span> inode *inode =  file ? file-&gt;f_path.dentry-&gt;d_inode : NULL;</pre>
<!--CRLF-->
<pre><span id="lnum167" style="color: #606060;"> 167:</span>&nbsp; </pre>
<!--CRLF-->
<pre><span id="lnum168" style="color: #606060;"> 168:</span>     <span style="color: #008000;">/* Clear old maps */</span></pre>
<!--CRLF-->
<pre><span id="lnum169" style="color: #606060;"> 169:</span>     error = -ENOMEM;</pre>
<!--CRLF-->
<pre><span id="lnum170" style="color: #606060;"> 170:</span> munmap_back:</pre>
<!--CRLF-->
<pre><span id="lnum171" style="color: #606060;"> 171:</span>     vma = find_vma_prepare(mm, addr, &amp;prev, &amp;rb_link, &amp;rb_parent);</pre>
<!--CRLF-->
<pre><span id="lnum172" style="color: #606060;"> 172:</span>     <span style="color: #0000ff;">if</span> (vma &amp;&amp; vma-&gt;vm_start &lt; addr + len) {</pre>
<!--CRLF-->
<pre><span id="lnum173" style="color: #606060;"> 173:</span>         <span style="color: #0000ff;">if</span> (do_munmap(mm, addr, len))</pre>
<!--CRLF-->
<pre><span id="lnum174" style="color: #606060;"> 174:</span>             <span style="color: #0000ff;">return</span> -ENOMEM;</pre>
<!--CRLF-->
<pre><span id="lnum175" style="color: #606060;"> 175:</span>         <span style="color: #0000ff;">goto</span> munmap_back;</pre>
<!--CRLF-->
<pre><span id="lnum176" style="color: #606060;"> 176:</span>     }</pre>
<!--CRLF-->
<pre><span id="lnum177" style="color: #606060;"> 177:</span>&nbsp; </pre>
<!--CRLF-->
<pre><span id="lnum178" style="color: #606060;"> 178:</span>     <span style="color: #008000;">/* Check against address space limit. */</span></pre>
<!--CRLF-->
<pre><span id="lnum179" style="color: #606060;"> 179:</span>     <span style="color: #0000ff;">if</span> (!may_expand_vm(mm, len &gt;&gt; PAGE_SHIFT))</pre>
<!--CRLF-->
<pre><span id="lnum180" style="color: #606060;"> 180:</span>         <span style="color: #0000ff;">return</span> -ENOMEM;</pre>
<!--CRLF-->
<pre><span id="lnum181" style="color: #606060;"> 181:</span>&nbsp; </pre>
<!--CRLF-->
<pre><span id="lnum182" style="color: #606060;"> 182:</span>     <span style="color: #008000;">/*</span></pre>
<!--CRLF-->
<pre><span id="lnum183" style="color: #606060;"> 183:</span> <span style="color: #008000;">     * Set 'VM_NORESERVE' if we should not account for the</span></pre>
<!--CRLF-->
<pre><span id="lnum184" style="color: #606060;"> 184:</span> <span style="color: #008000;">     * memory use of this mapping.</span></pre>
<!--CRLF-->
<pre><span id="lnum185" style="color: #606060;"> 185:</span> <span style="color: #008000;">     */</span></pre>
<!--CRLF-->
<pre><span id="lnum186" style="color: #606060;"> 186:</span>     <span style="color: #0000ff;">if</span> ((flags &amp; MAP_NORESERVE)) {</pre>
<!--CRLF-->
<pre><span id="lnum187" style="color: #606060;"> 187:</span>         <span style="color: #008000;">/* We honor MAP_NORESERVE if allowed to overcommit */</span></pre>
<!--CRLF-->
<pre><span id="lnum188" style="color: #606060;"> 188:</span>         <span style="color: #0000ff;">if</span> (sysctl_overcommit_memory != OVERCOMMIT_NEVER)</pre>
<!--CRLF-->
<pre><span id="lnum189" style="color: #606060;"> 189:</span>             vm_flags |= VM_NORESERVE;</pre>
<!--CRLF-->
<pre><span id="lnum190" style="color: #606060;"> 190:</span>&nbsp; </pre>
<!--CRLF-->
<pre><span id="lnum191" style="color: #606060;"> 191:</span>         <span style="color: #008000;">/* hugetlb applies strict overcommit unless MAP_NORESERVE */</span></pre>
<!--CRLF-->
<pre><span id="lnum192" style="color: #606060;"> 192:</span>         <span style="color: #0000ff;">if</span> (file &amp;&amp; is_file_hugepages(file))</pre>
<!--CRLF-->
<pre><span id="lnum193" style="color: #606060;"> 193:</span>             vm_flags |= VM_NORESERVE;</pre>
<!--CRLF-->
<pre><span id="lnum194" style="color: #606060;"> 194:</span>     }</pre>
<!--CRLF-->
<pre><span id="lnum195" style="color: #606060;"> 195:</span>&nbsp; </pre>
<!--CRLF-->
<pre><span id="lnum196" style="color: #606060;"> 196:</span>     <span style="color: #008000;">/*</span></pre>
<!--CRLF-->
<pre><span id="lnum197" style="color: #606060;"> 197:</span> <span style="color: #008000;">     * Private writable mapping: check memory availability</span></pre>
<!--CRLF-->
<pre><span id="lnum198" style="color: #606060;"> 198:</span> <span style="color: #008000;">     */</span></pre>
<!--CRLF-->
<pre><span id="lnum199" style="color: #606060;"> 199:</span>     <span style="color: #0000ff;">if</span> (accountable_mapping(file, vm_flags)) {</pre>
<!--CRLF-->
<pre><span id="lnum200" style="color: #606060;"> 200:</span>         charged = len &gt;&gt; PAGE_SHIFT;</pre>
<!--CRLF-->
<pre><span id="lnum201" style="color: #606060;"> 201:</span>         <span style="color: #0000ff;">if</span> (security_vm_enough_memory(charged))</pre>
<!--CRLF-->
<pre><span id="lnum202" style="color: #606060;"> 202:</span>             <span style="color: #0000ff;">return</span> -ENOMEM;</pre>
<!--CRLF-->
<pre><span id="lnum203" style="color: #606060;"> 203:</span>         vm_flags |= VM_ACCOUNT;</pre>
<!--CRLF-->
<pre><span id="lnum204" style="color: #606060;"> 204:</span>     }</pre>
<!--CRLF-->
<pre><span id="lnum205" style="color: #606060;"> 205:</span>&nbsp; </pre>
<!--CRLF-->
<pre><span id="lnum206" style="color: #606060;"> 206:</span>     <span style="color: #008000;">/*</span></pre>
<!--CRLF-->
<pre><span id="lnum207" style="color: #606060;"> 207:</span> <span style="color: #008000;">     * Can we just expand an old mapping?</span></pre>
<!--CRLF-->
<pre><span id="lnum208" style="color: #606060;"> 208:</span> <span style="color: #008000;">     */</span></pre>
<!--CRLF-->
<pre><span id="lnum209" style="color: #606060;"> 209:</span>     vma = vma_merge(mm, prev, addr, addr + len, vm_flags, NULL, file, pgoff, NULL);</pre>
<!--CRLF-->
<pre><span id="lnum210" style="color: #606060;"> 210:</span>     <span style="color: #0000ff;">if</span> (vma)</pre>
<!--CRLF-->
<pre><span id="lnum211" style="color: #606060;"> 211:</span>         <span style="color: #0000ff;">goto</span> out;</pre>
<!--CRLF-->
<pre><span id="lnum212" style="color: #606060;"> 212:</span>&nbsp; </pre>
<!--CRLF-->
<pre><span id="lnum213" style="color: #606060;"> 213:</span>     <span style="color: #008000;">/*</span></pre>
<!--CRLF-->
<pre><span id="lnum214" style="color: #606060;"> 214:</span> <span style="color: #008000;">     * Determine the object being mapped and call the appropriate</span></pre>
<!--CRLF-->
<pre><span id="lnum215" style="color: #606060;"> 215:</span> <span style="color: #008000;">     * specific mapper. the address has already been validated, but</span></pre>
<!--CRLF-->
<pre><span id="lnum216" style="color: #606060;"> 216:</span> <span style="color: #008000;">     * not unmapped, but the maps are removed from the list.</span></pre>
<!--CRLF-->
<pre><span id="lnum217" style="color: #606060;"> 217:</span> <span style="color: #008000;">     */</span></pre>
<!--CRLF-->
<pre><span id="lnum218" style="color: #606060;"> 218:</span>     vma = kmem_cache_zalloc(vm_area_cachep, GFP_KERNEL);</pre>
<!--CRLF-->
<pre><span id="lnum219" style="color: #606060;"> 219:</span>     <span style="color: #0000ff;">if</span> (!vma) {</pre>
<!--CRLF-->
<pre><span id="lnum220" style="color: #606060;"> 220:</span>         error = -ENOMEM;</pre>
<!--CRLF-->
<pre><span id="lnum221" style="color: #606060;"> 221:</span>         <span style="color: #0000ff;">goto</span> unacct_error;</pre>
<!--CRLF-->
<pre><span id="lnum222" style="color: #606060;"> 222:</span>     }</pre>
<!--CRLF-->
<pre><span id="lnum223" style="color: #606060;"> 223:</span>&nbsp; </pre>
<!--CRLF-->
<pre><span id="lnum224" style="color: #606060;"> 224:</span>     vma-&gt;vm_mm = mm;</pre>
<!--CRLF-->
<pre><span id="lnum225" style="color: #606060;"> 225:</span>     vma-&gt;vm_start = addr;</pre>
<!--CRLF-->
<pre><span id="lnum226" style="color: #606060;"> 226:</span>     vma-&gt;vm_end = addr + len;</pre>
<!--CRLF-->
<pre><span id="lnum227" style="color: #606060;"> 227:</span>     vma-&gt;vm_flags = vm_flags;</pre>
<!--CRLF-->
<pre><span id="lnum228" style="color: #606060;"> 228:</span>     vma-&gt;vm_page_prot = vm_get_page_prot(vm_flags);</pre>
<!--CRLF-->
<pre><span id="lnum229" style="color: #606060;"> 229:</span>     vma-&gt;vm_pgoff = pgoff;</pre>
<!--CRLF-->
<pre><span id="lnum230" style="color: #606060;"> 230:</span>     INIT_LIST_HEAD(&amp;vma-&gt;anon_vma_chain);</pre>
<!--CRLF-->
<pre><span id="lnum231" style="color: #606060;"> 231:</span>&nbsp; </pre>
<!--CRLF-->
<pre><span id="lnum232" style="color: #606060;"> 232:</span>     <span style="color: #0000ff;">if</span> (file) {</pre>
<!--CRLF-->
<pre><span id="lnum233" style="color: #606060;"> 233:</span>         error = -EINVAL;</pre>
<!--CRLF-->
<pre><span id="lnum234" style="color: #606060;"> 234:</span>         <span style="color: #0000ff;">if</span> (vm_flags &amp; (VM_GROWSDOWN|VM_GROWSUP))</pre>
<!--CRLF-->
<pre><span id="lnum235" style="color: #606060;"> 235:</span>             <span style="color: #0000ff;">goto</span> free_vma;</pre>
<!--CRLF-->
<pre><span id="lnum236" style="color: #606060;"> 236:</span>         <span style="color: #0000ff;">if</span> (vm_flags &amp; VM_DENYWRITE) {</pre>
<!--CRLF-->
<pre><span id="lnum237" style="color: #606060;"> 237:</span>             error = deny_write_access(file);</pre>
<!--CRLF-->
<pre><span id="lnum238" style="color: #606060;"> 238:</span>             <span style="color: #0000ff;">if</span> (error)</pre>
<!--CRLF-->
<pre><span id="lnum239" style="color: #606060;"> 239:</span>                 <span style="color: #0000ff;">goto</span> free_vma;</pre>
<!--CRLF-->
<pre><span id="lnum240" style="color: #606060;"> 240:</span>             correct_wcount = 1;</pre>
<!--CRLF-->
<pre><span id="lnum241" style="color: #606060;"> 241:</span>         }</pre>
<!--CRLF-->
<pre><span id="lnum242" style="color: #606060;"> 242:</span>         vma-&gt;vm_file = file;</pre>
<!--CRLF-->
<pre><span id="lnum243" style="color: #606060;"> 243:</span>         get_file(file);</pre>
<!--CRLF-->
<pre><span id="lnum244" style="color: #606060;"> 244:</span>         error = file-&gt;f_op-&gt;mmap(file, vma);</pre>
<!--CRLF-->
<pre><span id="lnum245" style="color: #606060;"> 245:</span>         <span style="color: #0000ff;">if</span> (error)</pre>
<!--CRLF-->
<pre><span id="lnum246" style="color: #606060;"> 246:</span>             <span style="color: #0000ff;">goto</span> unmap_and_free_vma;</pre>
<!--CRLF-->
<pre><span id="lnum247" style="color: #606060;"> 247:</span>         <span style="color: #0000ff;">if</span> (vm_flags &amp; VM_EXECUTABLE)</pre>
<!--CRLF-->
<pre><span id="lnum248" style="color: #606060;"> 248:</span>             added_exe_file_vma(mm);</pre>
<!--CRLF-->
<pre><span id="lnum249" style="color: #606060;"> 249:</span>&nbsp; </pre>
<!--CRLF-->
<pre><span id="lnum250" style="color: #606060;"> 250:</span>         <span style="color: #008000;">/* Can addr have changed??</span></pre>
<!--CRLF-->
<pre><span id="lnum251" style="color: #606060;"> 251:</span> <span style="color: #008000;">         *</span></pre>
<!--CRLF-->
<pre><span id="lnum252" style="color: #606060;"> 252:</span> <span style="color: #008000;">         * Answer: Yes, several device drivers can do it in their</span></pre>
<!--CRLF-->
<pre><span id="lnum253" style="color: #606060;"> 253:</span> <span style="color: #008000;">         *         f_op-&gt;mmap method. -DaveM</span></pre>
<!--CRLF-->
<pre><span id="lnum254" style="color: #606060;"> 254:</span> <span style="color: #008000;">         */</span></pre>
<!--CRLF-->
<pre><span id="lnum255" style="color: #606060;"> 255:</span>         addr = vma-&gt;vm_start;</pre>
<!--CRLF-->
<pre><span id="lnum256" style="color: #606060;"> 256:</span>         pgoff = vma-&gt;vm_pgoff;</pre>
<!--CRLF-->
<pre><span id="lnum257" style="color: #606060;"> 257:</span>         vm_flags = vma-&gt;vm_flags;</pre>
<!--CRLF-->
<pre><span id="lnum258" style="color: #606060;"> 258:</span>     } <span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (vm_flags &amp; VM_SHARED) {</pre>
<!--CRLF-->
<pre><span id="lnum259" style="color: #606060;"> 259:</span>         error = shmem_zero_setup(vma);</pre>
<!--CRLF-->
<pre><span id="lnum260" style="color: #606060;"> 260:</span>         <span style="color: #0000ff;">if</span> (error)</pre>
<!--CRLF-->
<pre><span id="lnum261" style="color: #606060;"> 261:</span>             <span style="color: #0000ff;">goto</span> free_vma;</pre>
<!--CRLF-->
<pre><span id="lnum262" style="color: #606060;"> 262:</span>     }</pre>
<!--CRLF-->
<pre><span id="lnum263" style="color: #606060;"> 263:</span>&nbsp; </pre>
<!--CRLF-->
<pre><span id="lnum264" style="color: #606060;"> 264:</span>     <span style="color: #0000ff;">if</span> (vma_wants_writenotify(vma)) {</pre>
<!--CRLF-->
<pre><span id="lnum265" style="color: #606060;"> 265:</span>         pgprot_t pprot = vma-&gt;vm_page_prot;</pre>
<!--CRLF-->
<pre><span id="lnum266" style="color: #606060;"> 266:</span>&nbsp; </pre>
<!--CRLF-->
<pre><span id="lnum267" style="color: #606060;"> 267:</span>         <span style="color: #008000;">/* Can vma-&gt;vm_page_prot have changed??</span></pre>
<!--CRLF-->
<pre><span id="lnum268" style="color: #606060;"> 268:</span> <span style="color: #008000;">         *</span></pre>
<!--CRLF-->
<pre><span id="lnum269" style="color: #606060;"> 269:</span> <span style="color: #008000;">         * Answer: Yes, drivers may have changed it in their</span></pre>
<!--CRLF-->
<pre><span id="lnum270" style="color: #606060;"> 270:</span> <span style="color: #008000;">         *         f_op-&gt;mmap method.</span></pre>
<!--CRLF-->
<pre><span id="lnum271" style="color: #606060;"> 271:</span> <span style="color: #008000;">         *</span></pre>
<!--CRLF-->
<pre><span id="lnum272" style="color: #606060;"> 272:</span> <span style="color: #008000;">         * Ensures that vmas marked as uncached stay that way.</span></pre>
<!--CRLF-->
<pre><span id="lnum273" style="color: #606060;"> 273:</span> <span style="color: #008000;">         */</span></pre>
<!--CRLF-->
<pre><span id="lnum274" style="color: #606060;"> 274:</span>         vma-&gt;vm_page_prot = vm_get_page_prot(vm_flags &amp; ~VM_SHARED);</pre>
<!--CRLF-->
<pre><span id="lnum275" style="color: #606060;"> 275:</span>         <span style="color: #0000ff;">if</span> (pgprot_val(pprot) == pgprot_val(pgprot_noncached(pprot)))</pre>
<!--CRLF-->
<pre><span id="lnum276" style="color: #606060;"> 276:</span>             vma-&gt;vm_page_prot = pgprot_noncached(vma-&gt;vm_page_prot);</pre>
<!--CRLF-->
<pre><span id="lnum277" style="color: #606060;"> 277:</span>     }</pre>
<!--CRLF-->
<pre><span id="lnum278" style="color: #606060;"> 278:</span>&nbsp; </pre>
<!--CRLF-->
<pre><span id="lnum279" style="color: #606060;"> 279:</span>     vma_link(mm, vma, prev, rb_link, rb_parent);</pre>
<!--CRLF-->
<pre><span id="lnum280" style="color: #606060;"> 280:</span>     file = vma-&gt;vm_file;</pre>
<!--CRLF-->
<pre><span id="lnum281" style="color: #606060;"> 281:</span>&nbsp; </pre>
<!--CRLF-->
<pre><span id="lnum282" style="color: #606060;"> 282:</span>     <span style="color: #008000;">/* Once vma denies write, undo our temporary denial count */</span></pre>
<!--CRLF-->
<pre><span id="lnum283" style="color: #606060;"> 283:</span>     <span style="color: #0000ff;">if</span> (correct_wcount)</pre>
<!--CRLF-->
<pre><span id="lnum284" style="color: #606060;"> 284:</span>         atomic_inc(&amp;inode-&gt;i_writecount);</pre>
<!--CRLF-->
<pre><span id="lnum285" style="color: #606060;"> 285:</span> out:</pre>
<!--CRLF-->
<pre><span id="lnum286" style="color: #606060;"> 286:</span>     perf_event_mmap(vma);</pre>
<!--CRLF-->
<pre><span id="lnum287" style="color: #606060;"> 287:</span>&nbsp; </pre>
<!--CRLF-->
<pre><span id="lnum288" style="color: #606060;"> 288:</span>     mm-&gt;total_vm += len &gt;&gt; PAGE_SHIFT;</pre>
<!--CRLF-->
<pre><span id="lnum289" style="color: #606060;"> 289:</span>     vm_stat_account(mm, vm_flags, file, len &gt;&gt; PAGE_SHIFT);</pre>
<!--CRLF-->
<pre><span id="lnum290" style="color: #606060;"> 290:</span>     <span style="color: #0000ff;">if</span> (vm_flags &amp; VM_LOCKED) {</pre>
<!--CRLF-->
<pre><span id="lnum291" style="color: #606060;"> 291:</span>         <span style="color: #0000ff;">if</span> (!mlock_vma_pages_range(vma, addr, addr + len))</pre>
<!--CRLF-->
<pre><span id="lnum292" style="color: #606060;"> 292:</span>             mm-&gt;locked_vm += (len &gt;&gt; PAGE_SHIFT);</pre>
<!--CRLF-->
<pre><span id="lnum293" style="color: #606060;"> 293:</span>     } <span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> ((flags &amp; MAP_POPULATE) &amp;&amp; !(flags &amp; MAP_NONBLOCK))</pre>
<!--CRLF-->
<pre><span id="lnum294" style="color: #606060;"> 294:</span>         make_pages_present(addr, addr + len);</pre>
<!--CRLF-->
<pre><span id="lnum295" style="color: #606060;"> 295:</span>     <span style="color: #0000ff;">return</span> addr;</pre>
<!--CRLF-->
<pre><span id="lnum296" style="color: #606060;"> 296:</span>&nbsp; </pre>
<!--CRLF-->
<pre><span id="lnum297" style="color: #606060;"> 297:</span> unmap_and_free_vma:</pre>
<!--CRLF-->
<pre><span id="lnum298" style="color: #606060;"> 298:</span>     <span style="color: #0000ff;">if</span> (correct_wcount)</pre>
<!--CRLF-->
<pre><span id="lnum299" style="color: #606060;"> 299:</span>         atomic_inc(&amp;inode-&gt;i_writecount);</pre>
<!--CRLF-->
<pre><span id="lnum300" style="color: #606060;"> 300:</span>     vma-&gt;vm_file = NULL;</pre>
<!--CRLF-->
<pre><span id="lnum301" style="color: #606060;"> 301:</span>     fput(file);</pre>
<!--CRLF-->
<pre><span id="lnum302" style="color: #606060;"> 302:</span>&nbsp; </pre>
<!--CRLF-->
<pre><span id="lnum303" style="color: #606060;"> 303:</span>     <span style="color: #008000;">/* Undo any partial mapping done by a device driver. */</span></pre>
<!--CRLF-->
<pre><span id="lnum304" style="color: #606060;"> 304:</span>     unmap_region(mm, vma, prev, vma-&gt;vm_start, vma-&gt;vm_end);</pre>
<!--CRLF-->
<pre><span id="lnum305" style="color: #606060;"> 305:</span>     charged = 0;</pre>
<!--CRLF-->
<pre><span id="lnum306" style="color: #606060;"> 306:</span> free_vma:</pre>
<!--CRLF-->
<pre><span id="lnum307" style="color: #606060;"> 307:</span>     kmem_cache_free(vm_area_cachep, vma);</pre>
<!--CRLF-->
<pre><span id="lnum308" style="color: #606060;"> 308:</span> unacct_error:</pre>
<!--CRLF-->
<pre><span id="lnum309" style="color: #606060;"> 309:</span>     <span style="color: #0000ff;">if</span> (charged)</pre>
<!--CRLF-->
<pre><span id="lnum310" style="color: #606060;"> 310:</span>         vm_unacct_memory(charged);</pre>
<!--CRLF-->
<pre><span id="lnum311" style="color: #606060;"> 311:</span>     <span style="color: #0000ff;">return</span> error;</pre>
<!--CRLF-->
<pre><span id="lnum312" style="color: #606060;"> 312:</span> }</pre>
<!--CRLF--></div>
</div>
<p>do_munmap， 释放一个内存区间</p>
<div id="codeSnippetWrapper" style="text-align: left; line-height: 12pt; background-color: #f4f4f4; margin: 20px 0px 10px; width: 97.5%; font-family: 'Courier New', courier, monospace; direction: ltr; max-height: 200px; font-size: 8pt; overflow: auto; cursor: text; border: silver 1px solid; padding: 4px;">
<div id="codeSnippet" style="text-align: left; line-height: 12pt; background-color: #f4f4f4; width: 100%; font-family: 'Courier New', courier, monospace; direction: ltr; color: black; font-size: 8pt; overflow: visible; border-style: none; padding: 0px;">
<pre><span id="lnum1" style="color: #606060;">   1:</span> <span style="color: #008000;">/* Munmap is split into 2 main parts -- this part which finds</span></pre>
<!--CRLF-->
<pre><span id="lnum2" style="color: #606060;">   2:</span> <span style="color: #008000;"> * what needs doing, and the areas themselves, which do the</span></pre>
<!--CRLF-->
<pre><span id="lnum3" style="color: #606060;">   3:</span> <span style="color: #008000;"> * work.  This now handles partial unmappings.</span></pre>
<!--CRLF-->
<pre><span id="lnum4" style="color: #606060;">   4:</span> <span style="color: #008000;"> * Jeremy Fitzhardinge &lt;jeremy@goop.org&gt;</span></pre>
<!--CRLF-->
<pre><span id="lnum5" style="color: #606060;">   5:</span> <span style="color: #008000;"> */</span></pre>
<!--CRLF-->
<pre><span id="lnum6" style="color: #606060;">   6:</span> <span style="color: #0000ff;">int</span> do_munmap(<span style="color: #0000ff;">struct</span> mm_struct *mm, <span style="color: #0000ff;">unsigned</span> <span style="color: #0000ff;">long</span> start, size_t len)</pre>
<!--CRLF-->
<pre><span id="lnum7" style="color: #606060;">   7:</span> {</pre>
<!--CRLF-->
<pre><span id="lnum8" style="color: #606060;">   8:</span>     <span style="color: #0000ff;">unsigned</span> <span style="color: #0000ff;">long</span> end;</pre>
<!--CRLF-->
<pre><span id="lnum9" style="color: #606060;">   9:</span>     <span style="color: #0000ff;">struct</span> vm_area_struct *vma, *prev, *last;</pre>
<!--CRLF-->
<pre><span id="lnum10" style="color: #606060;">  10:</span>&nbsp; </pre>
<!--CRLF-->
<pre><span id="lnum11" style="color: #606060;">  11:</span>     <span style="color: #0000ff;">if</span> ((start &amp; ~PAGE_MASK) || start &gt; TASK_SIZE || len &gt; TASK_SIZE-start)</pre>
<!--CRLF-->
<pre><span id="lnum12" style="color: #606060;">  12:</span>         <span style="color: #0000ff;">return</span> -EINVAL;</pre>
<!--CRLF-->
<pre><span id="lnum13" style="color: #606060;">  13:</span>&nbsp; </pre>
<!--CRLF-->
<pre><span id="lnum14" style="color: #606060;">  14:</span>     <span style="color: #0000ff;">if</span> ((len = PAGE_ALIGN(len)) == 0)</pre>
<!--CRLF-->
<pre><span id="lnum15" style="color: #606060;">  15:</span>         <span style="color: #0000ff;">return</span> -EINVAL;</pre>
<!--CRLF-->
<pre><span id="lnum16" style="color: #606060;">  16:</span>&nbsp; </pre>
<!--CRLF-->
<pre><span id="lnum17" style="color: #606060;">  17:</span>     <span style="color: #008000;">/* Find the first overlapping VMA */</span></pre>
<!--CRLF-->
<pre><span id="lnum18" style="color: #606060;">  18:</span>     vma = find_vma(mm, start);</pre>
<!--CRLF-->
<pre><span id="lnum19" style="color: #606060;">  19:</span>     <span style="color: #0000ff;">if</span> (!vma)</pre>
<!--CRLF-->
<pre><span id="lnum20" style="color: #606060;">  20:</span>         <span style="color: #0000ff;">return</span> 0;</pre>
<!--CRLF-->
<pre><span id="lnum21" style="color: #606060;">  21:</span>     prev = vma-&gt;vm_prev;</pre>
<!--CRLF-->
<pre><span id="lnum22" style="color: #606060;">  22:</span>     <span style="color: #008000;">/* we have  start &lt; vma-&gt;vm_end  */</span></pre>
<!--CRLF-->
<pre><span id="lnum23" style="color: #606060;">  23:</span>&nbsp; </pre>
<!--CRLF-->
<pre><span id="lnum24" style="color: #606060;">  24:</span>     <span style="color: #008000;">/* if it doesn't overlap, we have nothing.. */</span></pre>
<!--CRLF-->
<pre><span id="lnum25" style="color: #606060;">  25:</span>     end = start + len;</pre>
<!--CRLF-->
<pre><span id="lnum26" style="color: #606060;">  26:</span>     <span style="color: #0000ff;">if</span> (vma-&gt;vm_start &gt;= end)</pre>
<!--CRLF-->
<pre><span id="lnum27" style="color: #606060;">  27:</span>         <span style="color: #0000ff;">return</span> 0;</pre>
<!--CRLF-->
<pre><span id="lnum28" style="color: #606060;">  28:</span>&nbsp; </pre>
<!--CRLF-->
<pre><span id="lnum29" style="color: #606060;">  29:</span>     <span style="color: #008000;">/*</span></pre>
<!--CRLF-->
<pre><span id="lnum30" style="color: #606060;">  30:</span> <span style="color: #008000;">     * If we need to split any vma, do it now to save pain later.</span></pre>
<!--CRLF-->
<pre><span id="lnum31" style="color: #606060;">  31:</span> <span style="color: #008000;">     *</span></pre>
<!--CRLF-->
<pre><span id="lnum32" style="color: #606060;">  32:</span> <span style="color: #008000;">     * Note: mremap's move_vma VM_ACCOUNT handling assumes a partially</span></pre>
<!--CRLF-->
<pre><span id="lnum33" style="color: #606060;">  33:</span> <span style="color: #008000;">     * unmapped vm_area_struct will remain in use: so lower split_vma</span></pre>
<!--CRLF-->
<pre><span id="lnum34" style="color: #606060;">  34:</span> <span style="color: #008000;">     * places tmp vma above, and higher split_vma places tmp vma below.</span></pre>
<!--CRLF-->
<pre><span id="lnum35" style="color: #606060;">  35:</span> <span style="color: #008000;">     */</span></pre>
<!--CRLF-->
<pre><span id="lnum36" style="color: #606060;">  36:</span>     <span style="color: #0000ff;">if</span> (start &gt; vma-&gt;vm_start) {</pre>
<!--CRLF-->
<pre><span id="lnum37" style="color: #606060;">  37:</span>         <span style="color: #0000ff;">int</span> error;</pre>
<!--CRLF-->
<pre><span id="lnum38" style="color: #606060;">  38:</span>&nbsp; </pre>
<!--CRLF-->
<pre><span id="lnum39" style="color: #606060;">  39:</span>         <span style="color: #008000;">/*</span></pre>
<!--CRLF-->
<pre><span id="lnum40" style="color: #606060;">  40:</span> <span style="color: #008000;">         * Make sure that map_count on return from munmap() will</span></pre>
<!--CRLF-->
<pre><span id="lnum41" style="color: #606060;">  41:</span> <span style="color: #008000;">         * not exceed its limit; but let map_count go just above</span></pre>
<!--CRLF-->
<pre><span id="lnum42" style="color: #606060;">  42:</span> <span style="color: #008000;">         * its limit temporarily, to help free resources as expected.</span></pre>
<!--CRLF-->
<pre><span id="lnum43" style="color: #606060;">  43:</span> <span style="color: #008000;">         */</span></pre>
<!--CRLF-->
<pre><span id="lnum44" style="color: #606060;">  44:</span>         <span style="color: #0000ff;">if</span> (end &lt; vma-&gt;vm_end &amp;&amp; mm-&gt;map_count &gt;= sysctl_max_map_count)</pre>
<!--CRLF-->
<pre><span id="lnum45" style="color: #606060;">  45:</span>             <span style="color: #0000ff;">return</span> -ENOMEM;</pre>
<!--CRLF-->
<pre><span id="lnum46" style="color: #606060;">  46:</span>&nbsp; </pre>
<!--CRLF-->
<pre><span id="lnum47" style="color: #606060;">  47:</span>         error = __split_vma(mm, vma, start, 0);</pre>
<!--CRLF-->
<pre><span id="lnum48" style="color: #606060;">  48:</span>         <span style="color: #0000ff;">if</span> (error)</pre>
<!--CRLF-->
<pre><span id="lnum49" style="color: #606060;">  49:</span>             <span style="color: #0000ff;">return</span> error;</pre>
<!--CRLF-->
<pre><span id="lnum50" style="color: #606060;">  50:</span>         prev = vma;</pre>
<!--CRLF-->
<pre><span id="lnum51" style="color: #606060;">  51:</span>     }</pre>
<!--CRLF-->
<pre><span id="lnum52" style="color: #606060;">  52:</span>&nbsp; </pre>
<!--CRLF-->
<pre><span id="lnum53" style="color: #606060;">  53:</span>     <span style="color: #008000;">/* Does it split the last one? */</span></pre>
<!--CRLF-->
<pre><span id="lnum54" style="color: #606060;">  54:</span>     last = find_vma(mm, end);</pre>
<!--CRLF-->
<pre><span id="lnum55" style="color: #606060;">  55:</span>     <span style="color: #0000ff;">if</span> (last &amp;&amp; end &gt; last-&gt;vm_start) {</pre>
<!--CRLF-->
<pre><span id="lnum56" style="color: #606060;">  56:</span>         <span style="color: #0000ff;">int</span> error = __split_vma(mm, last, end, 1);</pre>
<!--CRLF-->
<pre><span id="lnum57" style="color: #606060;">  57:</span>         <span style="color: #0000ff;">if</span> (error)</pre>
<!--CRLF-->
<pre><span id="lnum58" style="color: #606060;">  58:</span>             <span style="color: #0000ff;">return</span> error;</pre>
<!--CRLF-->
<pre><span id="lnum59" style="color: #606060;">  59:</span>     }</pre>
<!--CRLF-->
<pre><span id="lnum60" style="color: #606060;">  60:</span>     vma = prev? prev-&gt;vm_next: mm-&gt;mmap;</pre>
<!--CRLF-->
<pre><span id="lnum61" style="color: #606060;">  61:</span>&nbsp; </pre>
<!--CRLF-->
<pre><span id="lnum62" style="color: #606060;">  62:</span>     <span style="color: #008000;">/*</span></pre>
<!--CRLF-->
<pre><span id="lnum63" style="color: #606060;">  63:</span> <span style="color: #008000;">     * unlock any mlock()ed ranges before detaching vmas</span></pre>
<!--CRLF-->
<pre><span id="lnum64" style="color: #606060;">  64:</span> <span style="color: #008000;">     */</span></pre>
<!--CRLF-->
<pre><span id="lnum65" style="color: #606060;">  65:</span>     <span style="color: #0000ff;">if</span> (mm-&gt;locked_vm) {</pre>
<!--CRLF-->
<pre><span id="lnum66" style="color: #606060;">  66:</span>         <span style="color: #0000ff;">struct</span> vm_area_struct *tmp = vma;</pre>
<!--CRLF-->
<pre><span id="lnum67" style="color: #606060;">  67:</span>         <span style="color: #0000ff;">while</span> (tmp &amp;&amp; tmp-&gt;vm_start &lt; end) {</pre>
<!--CRLF-->
<pre><span id="lnum68" style="color: #606060;">  68:</span>             <span style="color: #0000ff;">if</span> (tmp-&gt;vm_flags &amp; VM_LOCKED) {</pre>
<!--CRLF-->
<pre><span id="lnum69" style="color: #606060;">  69:</span>                 mm-&gt;locked_vm -= vma_pages(tmp);</pre>
<!--CRLF-->
<pre><span id="lnum70" style="color: #606060;">  70:</span>                 munlock_vma_pages_all(tmp);</pre>
<!--CRLF-->
<pre><span id="lnum71" style="color: #606060;">  71:</span>             }</pre>
<!--CRLF-->
<pre><span id="lnum72" style="color: #606060;">  72:</span>             tmp = tmp-&gt;vm_next;</pre>
<!--CRLF-->
<pre><span id="lnum73" style="color: #606060;">  73:</span>         }</pre>
<!--CRLF-->
<pre><span id="lnum74" style="color: #606060;">  74:</span>     }</pre>
<!--CRLF-->
<pre><span id="lnum75" style="color: #606060;">  75:</span>&nbsp; </pre>
<!--CRLF-->
<pre><span id="lnum76" style="color: #606060;">  76:</span>     <span style="color: #008000;">/*</span></pre>
<!--CRLF-->
<pre><span id="lnum77" style="color: #606060;">  77:</span> <span style="color: #008000;">     * Remove the vma's, and unmap the actual pages</span></pre>
<!--CRLF-->
<pre><span id="lnum78" style="color: #606060;">  78:</span> <span style="color: #008000;">     */</span></pre>
<!--CRLF-->
<pre><span id="lnum79" style="color: #606060;">  79:</span>     detach_vmas_to_be_unmapped(mm, vma, prev, end);</pre>
<!--CRLF-->
<pre><span id="lnum80" style="color: #606060;">  80:</span>     unmap_region(mm, vma, prev, start, end);</pre>
<!--CRLF-->
<pre><span id="lnum81" style="color: #606060;">  81:</span>&nbsp; </pre>
<!--CRLF-->
<pre><span id="lnum82" style="color: #606060;">  82:</span>     <span style="color: #008000;">/* Fix up all other VM information */</span></pre>
<!--CRLF-->
<pre><span id="lnum83" style="color: #606060;">  83:</span>     remove_vma_list(mm, vma);</pre>
<!--CRLF-->
<pre><span id="lnum84" style="color: #606060;">  84:</span>&nbsp; </pre>
<!--CRLF-->
<pre><span id="lnum85" style="color: #606060;">  85:</span>     <span style="color: #0000ff;">return</span> 0;</pre>
<!--CRLF-->
<pre><span id="lnum86" style="color: #606060;">  86:</span> }</pre>
<!--CRLF--></div>
</div>
<h3>Page Fault缺页异常</h3>
<div id="codeSnippetWrapper" style="text-align: left; line-height: 12pt; background-color: #f4f4f4; margin: 20px 0px 10px; width: 97.5%; font-family: 'Courier New', courier, monospace; direction: ltr; max-height: 200px; font-size: 8pt; overflow: auto; cursor: text; border: silver 1px solid; padding: 4px;">
<div id="codeSnippet" style="text-align: left; line-height: 12pt; background-color: #f4f4f4; width: 100%; font-family: 'Courier New', courier, monospace; direction: ltr; color: black; font-size: 8pt; overflow: visible; border-style: none; padding: 0px;">
<pre><span id="lnum1" style="color: #606060;">   1:</span> <span style="color: #008000;">/*</span></pre>
<!--CRLF-->
<pre><span id="lnum2" style="color: #606060;">   2:</span> <span style="color: #008000;"> * This routine handles page faults.  It determines the address,</span></pre>
<!--CRLF-->
<pre><span id="lnum3" style="color: #606060;">   3:</span> <span style="color: #008000;"> * and the problem, and then passes it off to one of the appropriate</span></pre>
<!--CRLF-->
<pre><span id="lnum4" style="color: #606060;">   4:</span> <span style="color: #008000;"> * routines.</span></pre>
<!--CRLF-->
<pre><span id="lnum5" style="color: #606060;">   5:</span> <span style="color: #008000;"> */</span></pre>
<!--CRLF-->
<pre><span id="lnum6" style="color: #606060;">   6:</span> dotraplinkage <span style="color: #0000ff;">void</span> __kprobes</pre>
<!--CRLF-->
<pre><span id="lnum7" style="color: #606060;">   7:</span> do_page_fault(<span style="color: #0000ff;">struct</span> pt_regs *regs, <span style="color: #0000ff;">unsigned</span> <span style="color: #0000ff;">long</span> error_code)</pre>
<!--CRLF-->
<pre><span id="lnum8" style="color: #606060;">   8:</span> {</pre>
<!--CRLF-->
<pre><span id="lnum9" style="color: #606060;">   9:</span>     <span style="color: #0000ff;">struct</span> vm_area_struct *vma;</pre>
<!--CRLF-->
<pre><span id="lnum10" style="color: #606060;">  10:</span>     <span style="color: #0000ff;">struct</span> task_struct *tsk;</pre>
<!--CRLF-->
<pre><span id="lnum11" style="color: #606060;">  11:</span>     <span style="color: #0000ff;">unsigned</span> <span style="color: #0000ff;">long</span> address;</pre>
<!--CRLF-->
<pre><span id="lnum12" style="color: #606060;">  12:</span>     <span style="color: #0000ff;">struct</span> mm_struct *mm;</pre>
<!--CRLF-->
<pre><span id="lnum13" style="color: #606060;">  13:</span>     <span style="color: #0000ff;">int</span> fault;</pre>
<!--CRLF-->
<pre><span id="lnum14" style="color: #606060;">  14:</span>     <span style="color: #0000ff;">int</span> write = error_code &amp; PF_WRITE;</pre>
<!--CRLF-->
<pre><span id="lnum15" style="color: #606060;">  15:</span>     <span style="color: #0000ff;">unsigned</span> <span style="color: #0000ff;">int</span> flags = FAULT_FLAG_ALLOW_RETRY | FAULT_FLAG_KILLABLE |</pre>
<!--CRLF-->
<pre><span id="lnum16" style="color: #606060;">  16:</span>                     (write ? FAULT_FLAG_WRITE : 0);</pre>
<!--CRLF-->
<pre><span id="lnum17" style="color: #606060;">  17:</span>&nbsp; </pre>
<!--CRLF-->
<pre><span id="lnum18" style="color: #606060;">  18:</span>     tsk = current;</pre>
<!--CRLF-->
<pre><span id="lnum19" style="color: #606060;">  19:</span>     mm = tsk-&gt;mm;</pre>
<!--CRLF-->
<pre><span id="lnum20" style="color: #606060;">  20:</span>&nbsp; </pre>
<!--CRLF-->
<pre><span id="lnum21" style="color: #606060;">  21:</span>     <span style="color: #008000;">/* Get the faulting address: */</span></pre>
<!--CRLF-->
<pre><span id="lnum22" style="color: #606060;">  22:</span>     address = read_cr2();</pre>
<!--CRLF-->
<pre><span id="lnum23" style="color: #606060;">  23:</span>&nbsp; </pre>
<!--CRLF-->
<pre><span id="lnum24" style="color: #606060;">  24:</span>     <span style="color: #008000;">/*</span></pre>
<!--CRLF-->
<pre><span id="lnum25" style="color: #606060;">  25:</span> <span style="color: #008000;">     * Detect and handle instructions that would cause a page fault for</span></pre>
<!--CRLF-->
<pre><span id="lnum26" style="color: #606060;">  26:</span> <span style="color: #008000;">     * both a tracked kernel page and a userspace page.</span></pre>
<!--CRLF-->
<pre><span id="lnum27" style="color: #606060;">  27:</span> <span style="color: #008000;">     */</span></pre>
<!--CRLF-->
<pre><span id="lnum28" style="color: #606060;">  28:</span>     <span style="color: #0000ff;">if</span> (kmemcheck_active(regs))</pre>
<!--CRLF-->
<pre><span id="lnum29" style="color: #606060;">  29:</span>         kmemcheck_hide(regs);</pre>
<!--CRLF-->
<pre><span id="lnum30" style="color: #606060;">  30:</span>     prefetchw(&amp;mm-&gt;mmap_sem);</pre>
<!--CRLF-->
<pre><span id="lnum31" style="color: #606060;">  31:</span>&nbsp; </pre>
<!--CRLF-->
<pre><span id="lnum32" style="color: #606060;">  32:</span>     <span style="color: #0000ff;">if</span> (unlikely(kmmio_fault(regs, address)))</pre>
<!--CRLF-->
<pre><span id="lnum33" style="color: #606060;">  33:</span>         <span style="color: #0000ff;">return</span>;</pre>
<!--CRLF-->
<pre><span id="lnum34" style="color: #606060;">  34:</span>&nbsp; </pre>
<!--CRLF-->
<pre><span id="lnum35" style="color: #606060;">  35:</span>     <span style="color: #008000;">/*</span></pre>
<!--CRLF-->
<pre><span id="lnum36" style="color: #606060;">  36:</span> <span style="color: #008000;">     * We fault-in kernel-space virtual memory on-demand. The</span></pre>
<!--CRLF-->
<pre><span id="lnum37" style="color: #606060;">  37:</span> <span style="color: #008000;">     * 'reference' page table is init_mm.pgd.</span></pre>
<!--CRLF-->
<pre><span id="lnum38" style="color: #606060;">  38:</span> <span style="color: #008000;">     *</span></pre>
<!--CRLF-->
<pre><span id="lnum39" style="color: #606060;">  39:</span> <span style="color: #008000;">     * NOTE! We MUST NOT take any locks for this case. We may</span></pre>
<!--CRLF-->
<pre><span id="lnum40" style="color: #606060;">  40:</span> <span style="color: #008000;">     * be in an interrupt or a critical region, and should</span></pre>
<!--CRLF-->
<pre><span id="lnum41" style="color: #606060;">  41:</span> <span style="color: #008000;">     * only copy the information from the master page table,</span></pre>
<!--CRLF-->
<pre><span id="lnum42" style="color: #606060;">  42:</span> <span style="color: #008000;">     * nothing more.</span></pre>
<!--CRLF-->
<pre><span id="lnum43" style="color: #606060;">  43:</span> <span style="color: #008000;">     *</span></pre>
<!--CRLF-->
<pre><span id="lnum44" style="color: #606060;">  44:</span> <span style="color: #008000;">     * This verifies that the fault happens in kernel space</span></pre>
<!--CRLF-->
<pre><span id="lnum45" style="color: #606060;">  45:</span> <span style="color: #008000;">     * (error_code &amp; 4) == 0, and that the fault was not a</span></pre>
<!--CRLF-->
<pre><span id="lnum46" style="color: #606060;">  46:</span> <span style="color: #008000;">     * protection error (error_code &amp; 9) == 0.</span></pre>
<!--CRLF-->
<pre><span id="lnum47" style="color: #606060;">  47:</span> <span style="color: #008000;">     */</span></pre>
<!--CRLF-->
<pre><span id="lnum48" style="color: #606060;">  48:</span>     <span style="color: #0000ff;">if</span> (unlikely(fault_in_kernel_space(address))) {</pre>
<!--CRLF-->
<pre><span id="lnum49" style="color: #606060;">  49:</span>         <span style="color: #0000ff;">if</span> (!(error_code &amp; (PF_RSVD | PF_USER | PF_PROT))) {</pre>
<!--CRLF-->
<pre><span id="lnum50" style="color: #606060;">  50:</span>             <span style="color: #0000ff;">if</span> (vmalloc_fault(address) &gt;= 0)</pre>
<!--CRLF-->
<pre><span id="lnum51" style="color: #606060;">  51:</span>                 <span style="color: #0000ff;">return</span>;</pre>
<!--CRLF-->
<pre><span id="lnum52" style="color: #606060;">  52:</span>&nbsp; </pre>
<!--CRLF-->
<pre><span id="lnum53" style="color: #606060;">  53:</span>             <span style="color: #0000ff;">if</span> (kmemcheck_fault(regs, address, error_code))</pre>
<!--CRLF-->
<pre><span id="lnum54" style="color: #606060;">  54:</span>                 <span style="color: #0000ff;">return</span>;</pre>
<!--CRLF-->
<pre><span id="lnum55" style="color: #606060;">  55:</span>         }</pre>
<!--CRLF-->
<pre><span id="lnum56" style="color: #606060;">  56:</span>&nbsp; </pre>
<!--CRLF-->
<pre><span id="lnum57" style="color: #606060;">  57:</span>         <span style="color: #008000;">/* Can handle a stale RO-&gt;RW TLB: */</span></pre>
<!--CRLF-->
<pre><span id="lnum58" style="color: #606060;">  58:</span>         <span style="color: #0000ff;">if</span> (spurious_fault(error_code, address))</pre>
<!--CRLF-->
<pre><span id="lnum59" style="color: #606060;">  59:</span>             <span style="color: #0000ff;">return</span>;</pre>
<!--CRLF-->
<pre><span id="lnum60" style="color: #606060;">  60:</span>&nbsp; </pre>
<!--CRLF-->
<pre><span id="lnum61" style="color: #606060;">  61:</span>         <span style="color: #008000;">/* kprobes don't want to hook the spurious faults: */</span></pre>
<!--CRLF-->
<pre><span id="lnum62" style="color: #606060;">  62:</span>         <span style="color: #0000ff;">if</span> (notify_page_fault(regs))</pre>
<!--CRLF-->
<pre><span id="lnum63" style="color: #606060;">  63:</span>             <span style="color: #0000ff;">return</span>;</pre>
<!--CRLF-->
<pre><span id="lnum64" style="color: #606060;">  64:</span>         <span style="color: #008000;">/*</span></pre>
<!--CRLF-->
<pre><span id="lnum65" style="color: #606060;">  65:</span> <span style="color: #008000;">         * Don't take the mm semaphore here. If we fixup a prefetch</span></pre>
<!--CRLF-->
<pre><span id="lnum66" style="color: #606060;">  66:</span> <span style="color: #008000;">         * fault we could otherwise deadlock:</span></pre>
<!--CRLF-->
<pre><span id="lnum67" style="color: #606060;">  67:</span> <span style="color: #008000;">         */</span></pre>
<!--CRLF-->
<pre><span id="lnum68" style="color: #606060;">  68:</span>         bad_area_nosemaphore(regs, error_code, address);</pre>
<!--CRLF-->
<pre><span id="lnum69" style="color: #606060;">  69:</span>&nbsp; </pre>
<!--CRLF-->
<pre><span id="lnum70" style="color: #606060;">  70:</span>         <span style="color: #0000ff;">return</span>;</pre>
<!--CRLF-->
<pre><span id="lnum71" style="color: #606060;">  71:</span>     }</pre>
<!--CRLF-->
<pre><span id="lnum72" style="color: #606060;">  72:</span>&nbsp; </pre>
<!--CRLF-->
<pre><span id="lnum73" style="color: #606060;">  73:</span>     <span style="color: #008000;">/* kprobes don't want to hook the spurious faults: */</span></pre>
<!--CRLF-->
<pre><span id="lnum74" style="color: #606060;">  74:</span>     <span style="color: #0000ff;">if</span> (unlikely(notify_page_fault(regs)))</pre>
<!--CRLF-->
<pre><span id="lnum75" style="color: #606060;">  75:</span>         <span style="color: #0000ff;">return</span>;</pre>
<!--CRLF-->
<pre><span id="lnum76" style="color: #606060;">  76:</span>     <span style="color: #008000;">/*</span></pre>
<!--CRLF-->
<pre><span id="lnum77" style="color: #606060;">  77:</span> <span style="color: #008000;">     * It's safe to allow irq's after cr2 has been saved and the</span></pre>
<!--CRLF-->
<pre><span id="lnum78" style="color: #606060;">  78:</span> <span style="color: #008000;">     * vmalloc fault has been handled.</span></pre>
<!--CRLF-->
<pre><span id="lnum79" style="color: #606060;">  79:</span> <span style="color: #008000;">     *</span></pre>
<!--CRLF-->
<pre><span id="lnum80" style="color: #606060;">  80:</span> <span style="color: #008000;">     * User-mode registers count as a user access even for any</span></pre>
<!--CRLF-->
<pre><span id="lnum81" style="color: #606060;">  81:</span> <span style="color: #008000;">     * potential system fault or CPU buglet:</span></pre>
<!--CRLF-->
<pre><span id="lnum82" style="color: #606060;">  82:</span> <span style="color: #008000;">     */</span></pre>
<!--CRLF-->
<pre><span id="lnum83" style="color: #606060;">  83:</span>     <span style="color: #0000ff;">if</span> (user_mode_vm(regs)) {</pre>
<!--CRLF-->
<pre><span id="lnum84" style="color: #606060;">  84:</span>         local_irq_enable();</pre>
<!--CRLF-->
<pre><span id="lnum85" style="color: #606060;">  85:</span>         error_code |= PF_USER;</pre>
<!--CRLF-->
<pre><span id="lnum86" style="color: #606060;">  86:</span>     } <span style="color: #0000ff;">else</span> {</pre>
<!--CRLF-->
<pre><span id="lnum87" style="color: #606060;">  87:</span>         <span style="color: #0000ff;">if</span> (regs-&gt;flags &amp; X86_EFLAGS_IF)</pre>
<!--CRLF-->
<pre><span id="lnum88" style="color: #606060;">  88:</span>             local_irq_enable();</pre>
<!--CRLF-->
<pre><span id="lnum89" style="color: #606060;">  89:</span>     }</pre>
<!--CRLF-->
<pre><span id="lnum90" style="color: #606060;">  90:</span>&nbsp; </pre>
<!--CRLF-->
<pre><span id="lnum91" style="color: #606060;">  91:</span>     <span style="color: #0000ff;">if</span> (unlikely(error_code &amp; PF_RSVD))</pre>
<!--CRLF-->
<pre><span id="lnum92" style="color: #606060;">  92:</span>         pgtable_bad(regs, error_code, address);</pre>
<!--CRLF-->
<pre><span id="lnum93" style="color: #606060;">  93:</span>&nbsp; </pre>
<!--CRLF-->
<pre><span id="lnum94" style="color: #606060;">  94:</span>     perf_sw_event(PERF_COUNT_SW_PAGE_FAULTS, 1, 0, regs, address);</pre>
<!--CRLF-->
<pre><span id="lnum95" style="color: #606060;">  95:</span>&nbsp; </pre>
<!--CRLF-->
<pre><span id="lnum96" style="color: #606060;">  96:</span>     <span style="color: #008000;">/*</span></pre>
<!--CRLF-->
<pre><span id="lnum97" style="color: #606060;">  97:</span> <span style="color: #008000;">     * If we're in an interrupt, have no user context or are running</span></pre>
<!--CRLF-->
<pre><span id="lnum98" style="color: #606060;">  98:</span> <span style="color: #008000;">     * in an atomic region then we must not take the fault:</span></pre>
<!--CRLF-->
<pre><span id="lnum99" style="color: #606060;">  99:</span> <span style="color: #008000;">     */</span></pre>
<!--CRLF-->
<pre><span id="lnum100" style="color: #606060;"> 100:</span>     <span style="color: #0000ff;">if</span> (unlikely(in_atomic() || !mm)) {</pre>
<!--CRLF-->
<pre><span id="lnum101" style="color: #606060;"> 101:</span>         bad_area_nosemaphore(regs, error_code, address);</pre>
<!--CRLF-->
<pre><span id="lnum102" style="color: #606060;"> 102:</span>         <span style="color: #0000ff;">return</span>;</pre>
<!--CRLF-->
<pre><span id="lnum103" style="color: #606060;"> 103:</span>     }</pre>
<!--CRLF-->
<pre><span id="lnum104" style="color: #606060;"> 104:</span>&nbsp; </pre>
<!--CRLF-->
<pre><span id="lnum105" style="color: #606060;"> 105:</span>     <span style="color: #008000;">/*</span></pre>
<!--CRLF-->
<pre><span id="lnum106" style="color: #606060;"> 106:</span> <span style="color: #008000;">     * When running in the kernel we expect faults to occur only to</span></pre>
<!--CRLF-->
<pre><span id="lnum107" style="color: #606060;"> 107:</span> <span style="color: #008000;">     * addresses in user space.  All other faults represent errors in</span></pre>
<!--CRLF-->
<pre><span id="lnum108" style="color: #606060;"> 108:</span> <span style="color: #008000;">     * the kernel and should generate an OOPS.  Unfortunately, in the</span></pre>
<!--CRLF-->
<pre><span id="lnum109" style="color: #606060;"> 109:</span> <span style="color: #008000;">     * case of an erroneous fault occurring in a code path which already</span></pre>
<!--CRLF-->
<pre><span id="lnum110" style="color: #606060;"> 110:</span> <span style="color: #008000;">     * holds mmap_sem we will deadlock attempting to validate the fault</span></pre>
<!--CRLF-->
<pre><span id="lnum111" style="color: #606060;"> 111:</span> <span style="color: #008000;">     * against the address space.  Luckily the kernel only validly</span></pre>
<!--CRLF-->
<pre><span id="lnum112" style="color: #606060;"> 112:</span> <span style="color: #008000;">     * references user space from well defined areas of code, which are</span></pre>
<!--CRLF-->
<pre><span id="lnum113" style="color: #606060;"> 113:</span> <span style="color: #008000;">     * listed in the exceptions table.</span></pre>
<!--CRLF-->
<pre><span id="lnum114" style="color: #606060;"> 114:</span> <span style="color: #008000;">     *</span></pre>
<!--CRLF-->
<pre><span id="lnum115" style="color: #606060;"> 115:</span> <span style="color: #008000;">     * As the vast majority of faults will be valid we will only perform</span></pre>
<!--CRLF-->
<pre><span id="lnum116" style="color: #606060;"> 116:</span> <span style="color: #008000;">     * the source reference check when there is a possibility of a</span></pre>
<!--CRLF-->
<pre><span id="lnum117" style="color: #606060;"> 117:</span> <span style="color: #008000;">     * deadlock. Attempt to lock the address space, if we cannot we then</span></pre>
<!--CRLF-->
<pre><span id="lnum118" style="color: #606060;"> 118:</span> <span style="color: #008000;">     * validate the source. If this is invalid we can skip the address</span></pre>
<!--CRLF-->
<pre><span id="lnum119" style="color: #606060;"> 119:</span> <span style="color: #008000;">     * space check, thus avoiding the deadlock:</span></pre>
<!--CRLF-->
<pre><span id="lnum120" style="color: #606060;"> 120:</span> <span style="color: #008000;">     */</span></pre>
<!--CRLF-->
<pre><span id="lnum121" style="color: #606060;"> 121:</span>     <span style="color: #0000ff;">if</span> (unlikely(!down_read_trylock(&amp;mm-&gt;mmap_sem))) {</pre>
<!--CRLF-->
<pre><span id="lnum122" style="color: #606060;"> 122:</span>         <span style="color: #0000ff;">if</span> ((error_code &amp; PF_USER) == 0 &amp;&amp;</pre>
<!--CRLF-->
<pre><span id="lnum123" style="color: #606060;"> 123:</span>             !search_exception_tables(regs-&gt;ip)) {</pre>
<!--CRLF-->
<pre><span id="lnum124" style="color: #606060;"> 124:</span>             bad_area_nosemaphore(regs, error_code, address);</pre>
<!--CRLF-->
<pre><span id="lnum125" style="color: #606060;"> 125:</span>             <span style="color: #0000ff;">return</span>;</pre>
<!--CRLF-->
<pre><span id="lnum126" style="color: #606060;"> 126:</span>         }</pre>
<!--CRLF-->
<pre><span id="lnum127" style="color: #606060;"> 127:</span> retry:</pre>
<!--CRLF-->
<pre><span id="lnum128" style="color: #606060;"> 128:</span>         down_read(&amp;mm-&gt;mmap_sem);</pre>
<!--CRLF-->
<pre><span id="lnum129" style="color: #606060;"> 129:</span>     } <span style="color: #0000ff;">else</span> {</pre>
<!--CRLF-->
<pre><span id="lnum130" style="color: #606060;"> 130:</span>         <span style="color: #008000;">/*</span></pre>
<!--CRLF-->
<pre><span id="lnum131" style="color: #606060;"> 131:</span> <span style="color: #008000;">         * The above down_read_trylock() might have succeeded in</span></pre>
<!--CRLF-->
<pre><span id="lnum132" style="color: #606060;"> 132:</span> <span style="color: #008000;">         * which case we'll have missed the might_sleep() from</span></pre>
<!--CRLF-->
<pre><span id="lnum133" style="color: #606060;"> 133:</span> <span style="color: #008000;">         * down_read():</span></pre>
<!--CRLF-->
<pre><span id="lnum134" style="color: #606060;"> 134:</span> <span style="color: #008000;">         */</span></pre>
<!--CRLF-->
<pre><span id="lnum135" style="color: #606060;"> 135:</span>         might_sleep();</pre>
<!--CRLF-->
<pre><span id="lnum136" style="color: #606060;"> 136:</span>     }</pre>
<!--CRLF-->
<pre><span id="lnum137" style="color: #606060;"> 137:</span>&nbsp; </pre>
<!--CRLF-->
<pre><span id="lnum138" style="color: #606060;"> 138:</span>     vma = find_vma(mm, address);</pre>
<!--CRLF-->
<pre><span id="lnum139" style="color: #606060;"> 139:</span>     <span style="color: #0000ff;">if</span> (unlikely(!vma)) {</pre>
<!--CRLF-->
<pre><span id="lnum140" style="color: #606060;"> 140:</span>         bad_area(regs, error_code, address);</pre>
<!--CRLF-->
<pre><span id="lnum141" style="color: #606060;"> 141:</span>         <span style="color: #0000ff;">return</span>;</pre>
<!--CRLF-->
<pre><span id="lnum142" style="color: #606060;"> 142:</span>     }</pre>
<!--CRLF-->
<pre><span id="lnum143" style="color: #606060;"> 143:</span>     <span style="color: #0000ff;">if</span> (likely(vma-&gt;vm_start &lt;= address))</pre>
<!--CRLF-->
<pre><span id="lnum144" style="color: #606060;"> 144:</span>         <span style="color: #0000ff;">goto</span> good_area;</pre>
<!--CRLF-->
<pre><span id="lnum145" style="color: #606060;"> 145:</span>     <span style="color: #0000ff;">if</span> (unlikely(!(vma-&gt;vm_flags &amp; VM_GROWSDOWN))) {</pre>
<!--CRLF-->
<pre><span id="lnum146" style="color: #606060;"> 146:</span>         bad_area(regs, error_code, address);</pre>
<!--CRLF-->
<pre><span id="lnum147" style="color: #606060;"> 147:</span>         <span style="color: #0000ff;">return</span>;</pre>
<!--CRLF-->
<pre><span id="lnum148" style="color: #606060;"> 148:</span>     }</pre>
<!--CRLF-->
<pre><span id="lnum149" style="color: #606060;"> 149:</span>     <span style="color: #0000ff;">if</span> (error_code &amp; PF_USER) {</pre>
<!--CRLF-->
<pre><span id="lnum150" style="color: #606060;"> 150:</span>         <span style="color: #008000;">/*</span></pre>
<!--CRLF-->
<pre><span id="lnum151" style="color: #606060;"> 151:</span> <span style="color: #008000;">         * Accessing the stack below %sp is always a bug.</span></pre>
<!--CRLF-->
<pre><span id="lnum152" style="color: #606060;"> 152:</span> <span style="color: #008000;">         * The large cushion allows instructions like enter</span></pre>
<!--CRLF-->
<pre><span id="lnum153" style="color: #606060;"> 153:</span> <span style="color: #008000;">         * and pusha to work. ("enter $65535, $31" pushes</span></pre>
<!--CRLF-->
<pre><span id="lnum154" style="color: #606060;"> 154:</span> <span style="color: #008000;">         * 32 pointers and then decrements %sp by 65535.)</span></pre>
<!--CRLF-->
<pre><span id="lnum155" style="color: #606060;"> 155:</span> <span style="color: #008000;">         */</span></pre>
<!--CRLF-->
<pre><span id="lnum156" style="color: #606060;"> 156:</span>         <span style="color: #0000ff;">if</span> (unlikely(address + 65536 + 32 * <span style="color: #0000ff;">sizeof</span>(<span style="color: #0000ff;">unsigned</span> <span style="color: #0000ff;">long</span>) &lt; regs-&gt;sp)) {</pre>
<!--CRLF-->
<pre><span id="lnum157" style="color: #606060;"> 157:</span>             bad_area(regs, error_code, address);</pre>
<!--CRLF-->
<pre><span id="lnum158" style="color: #606060;"> 158:</span>             <span style="color: #0000ff;">return</span>;</pre>
<!--CRLF-->
<pre><span id="lnum159" style="color: #606060;"> 159:</span>         }</pre>
<!--CRLF-->
<pre><span id="lnum160" style="color: #606060;"> 160:</span>     }</pre>
<!--CRLF-->
<pre><span id="lnum161" style="color: #606060;"> 161:</span>     <span style="color: #0000ff;">if</span> (unlikely(expand_stack(vma, address))) {</pre>
<!--CRLF-->
<pre><span id="lnum162" style="color: #606060;"> 162:</span>         bad_area(regs, error_code, address);</pre>
<!--CRLF-->
<pre><span id="lnum163" style="color: #606060;"> 163:</span>         <span style="color: #0000ff;">return</span>;</pre>
<!--CRLF-->
<pre><span id="lnum164" style="color: #606060;"> 164:</span>     }</pre>
<!--CRLF-->
<pre><span id="lnum165" style="color: #606060;"> 165:</span>&nbsp; </pre>
<!--CRLF-->
<pre><span id="lnum166" style="color: #606060;"> 166:</span>     <span style="color: #008000;">/*</span></pre>
<!--CRLF-->
<pre><span id="lnum167" style="color: #606060;"> 167:</span> <span style="color: #008000;">     * Ok, we have a good vm_area for this memory access, so</span></pre>
<!--CRLF-->
<pre><span id="lnum168" style="color: #606060;"> 168:</span> <span style="color: #008000;">     * we can handle it..</span></pre>
<!--CRLF-->
<pre><span id="lnum169" style="color: #606060;"> 169:</span> <span style="color: #008000;">     */</span></pre>
<!--CRLF-->
<pre><span id="lnum170" style="color: #606060;"> 170:</span> good_area:</pre>
<!--CRLF-->
<pre><span id="lnum171" style="color: #606060;"> 171:</span>     <span style="color: #0000ff;">if</span> (unlikely(access_error(error_code, vma))) {</pre>
<!--CRLF-->
<pre><span id="lnum172" style="color: #606060;"> 172:</span>         bad_area_access_error(regs, error_code, address);</pre>
<!--CRLF-->
<pre><span id="lnum173" style="color: #606060;"> 173:</span>         <span style="color: #0000ff;">return</span>;</pre>
<!--CRLF-->
<pre><span id="lnum174" style="color: #606060;"> 174:</span>     }</pre>
<!--CRLF-->
<pre><span id="lnum175" style="color: #606060;"> 175:</span>&nbsp; </pre>
<!--CRLF-->
<pre><span id="lnum176" style="color: #606060;"> 176:</span>     <span style="color: #008000;">/*</span></pre>
<!--CRLF-->
<pre><span id="lnum177" style="color: #606060;"> 177:</span> <span style="color: #008000;">     * If for any reason at all we couldn't handle the fault,</span></pre>
<!--CRLF-->
<pre><span id="lnum178" style="color: #606060;"> 178:</span> <span style="color: #008000;">     * make sure we exit gracefully rather than endlessly redo</span></pre>
<!--CRLF-->
<pre><span id="lnum179" style="color: #606060;"> 179:</span> <span style="color: #008000;">     * the fault:</span></pre>
<!--CRLF-->
<pre><span id="lnum180" style="color: #606060;"> 180:</span> <span style="color: #008000;">     */</span></pre>
<!--CRLF-->
<pre><span id="lnum181" style="color: #606060;"> 181:</span>     fault = handle_mm_fault(mm, vma, address, flags);</pre>
<!--CRLF-->
<pre><span id="lnum182" style="color: #606060;"> 182:</span>&nbsp; </pre>
<!--CRLF-->
<pre><span id="lnum183" style="color: #606060;"> 183:</span>     <span style="color: #0000ff;">if</span> (unlikely(fault &amp; (VM_FAULT_RETRY|VM_FAULT_ERROR))) {</pre>
<!--CRLF-->
<pre><span id="lnum184" style="color: #606060;"> 184:</span>         <span style="color: #0000ff;">if</span> (mm_fault_error(regs, error_code, address, fault))</pre>
<!--CRLF-->
<pre><span id="lnum185" style="color: #606060;"> 185:</span>             <span style="color: #0000ff;">return</span>;</pre>
<!--CRLF-->
<pre><span id="lnum186" style="color: #606060;"> 186:</span>     }</pre>
<!--CRLF-->
<pre><span id="lnum187" style="color: #606060;"> 187:</span>&nbsp; </pre>
<!--CRLF-->
<pre><span id="lnum188" style="color: #606060;"> 188:</span>     <span style="color: #008000;">/*</span></pre>
<!--CRLF-->
<pre><span id="lnum189" style="color: #606060;"> 189:</span> <span style="color: #008000;">     * Major/minor page fault accounting is only done on the</span></pre>
<!--CRLF-->
<pre><span id="lnum190" style="color: #606060;"> 190:</span> <span style="color: #008000;">     * initial attempt. If we go through a retry, it is extremely</span></pre>
<!--CRLF-->
<pre><span id="lnum191" style="color: #606060;"> 191:</span> <span style="color: #008000;">     * likely that the page will be found in page cache at that point.</span></pre>
<!--CRLF-->
<pre><span id="lnum192" style="color: #606060;"> 192:</span> <span style="color: #008000;">     */</span></pre>
<!--CRLF-->
<pre><span id="lnum193" style="color: #606060;"> 193:</span>     <span style="color: #0000ff;">if</span> (flags &amp; FAULT_FLAG_ALLOW_RETRY) {</pre>
<!--CRLF-->
<pre><span id="lnum194" style="color: #606060;"> 194:</span>         <span style="color: #0000ff;">if</span> (fault &amp; VM_FAULT_MAJOR) {</pre>
<!--CRLF-->
<pre><span id="lnum195" style="color: #606060;"> 195:</span>             tsk-&gt;maj_flt++;</pre>
<!--CRLF-->
<pre><span id="lnum196" style="color: #606060;"> 196:</span>             perf_sw_event(PERF_COUNT_SW_PAGE_FAULTS_MAJ, 1, 0,</pre>
<!--CRLF-->
<pre><span id="lnum197" style="color: #606060;"> 197:</span>                       regs, address);</pre>
<!--CRLF-->
<pre><span id="lnum198" style="color: #606060;"> 198:</span>         } <span style="color: #0000ff;">else</span> {</pre>
<!--CRLF-->
<pre><span id="lnum199" style="color: #606060;"> 199:</span>             tsk-&gt;min_flt++;</pre>
<!--CRLF-->
<pre><span id="lnum200" style="color: #606060;"> 200:</span>             perf_sw_event(PERF_COUNT_SW_PAGE_FAULTS_MIN, 1, 0,</pre>
<!--CRLF-->
<pre><span id="lnum201" style="color: #606060;"> 201:</span>                       regs, address);</pre>
<!--CRLF-->
<pre><span id="lnum202" style="color: #606060;"> 202:</span>         }</pre>
<!--CRLF-->
<pre><span id="lnum203" style="color: #606060;"> 203:</span>         <span style="color: #0000ff;">if</span> (fault &amp; VM_FAULT_RETRY) {</pre>
<!--CRLF-->
<pre><span id="lnum204" style="color: #606060;"> 204:</span>             <span style="color: #008000;">/* Clear FAULT_FLAG_ALLOW_RETRY to avoid any risk</span></pre>
<!--CRLF-->
<pre><span id="lnum205" style="color: #606060;"> 205:</span> <span style="color: #008000;">             * of starvation. */</span></pre>
<!--CRLF-->
<pre><span id="lnum206" style="color: #606060;"> 206:</span>             flags &amp;= ~FAULT_FLAG_ALLOW_RETRY;</pre>
<!--CRLF-->
<pre><span id="lnum207" style="color: #606060;"> 207:</span>             <span style="color: #0000ff;">goto</span> retry;</pre>
<!--CRLF-->
<pre><span id="lnum208" style="color: #606060;"> 208:</span>         }</pre>
<!--CRLF-->
<pre><span id="lnum209" style="color: #606060;"> 209:</span>     }</pre>
<!--CRLF-->
<pre><span id="lnum210" style="color: #606060;"> 210:</span>&nbsp; </pre>
<!--CRLF-->
<pre><span id="lnum211" style="color: #606060;"> 211:</span>     check_v8086_mode(regs, address, tsk);</pre>
<!--CRLF-->
<pre><span id="lnum212" style="color: #606060;"> 212:</span>&nbsp; </pre>
<!--CRLF-->
<pre><span id="lnum213" style="color: #606060;"> 213:</span>     up_read(&amp;mm-&gt;mmap_sem);</pre>
<!--CRLF-->
<pre><span id="lnum214" style="color: #606060;"> 214:</span> }</pre>
<!--CRLF--></div>
</div>
<p>引起缺页异常的线性地址，被保存在CR2寄存器中</p>
<blockquote>
<p>/* Get the faulting address: */<br />&nbsp;&nbsp;&nbsp; address = read_cr2();</p>
</blockquote>
<p>Demand Paging按需调页</p>
<div id="codeSnippetWrapper" style="text-align: left; line-height: 12pt; background-color: #f4f4f4; margin: 20px 0px 10px; width: 97.5%; font-family: 'Courier New', courier, monospace; direction: ltr; max-height: 200px; font-size: 8pt; overflow: auto; cursor: text; border: silver 1px solid; padding: 4px;">
<div id="codeSnippet" style="text-align: left; line-height: 12pt; background-color: #f4f4f4; width: 100%; font-family: 'Courier New', courier, monospace; direction: ltr; color: black; font-size: 8pt; overflow: visible; border-style: none; padding: 0px;">
<pre><span id="lnum1" style="color: #606060;">   1:</span> <span style="color: #008000;">/*</span></pre>
<!--CRLF-->
<pre><span id="lnum2" style="color: #606060;">   2:</span> <span style="color: #008000;"> * By the time we get here, we already hold the mm semaphore</span></pre>
<!--CRLF-->
<pre><span id="lnum3" style="color: #606060;">   3:</span> <span style="color: #008000;"> */</span></pre>
<!--CRLF-->
<pre><span id="lnum4" style="color: #606060;">   4:</span> <span style="color: #0000ff;">int</span> handle_mm_fault(<span style="color: #0000ff;">struct</span> mm_struct *mm, <span style="color: #0000ff;">struct</span> vm_area_struct *vma,</pre>
<!--CRLF-->
<pre><span id="lnum5" style="color: #606060;">   5:</span>         <span style="color: #0000ff;">unsigned</span> <span style="color: #0000ff;">long</span> address, <span style="color: #0000ff;">unsigned</span> <span style="color: #0000ff;">int</span> flags)</pre>
<!--CRLF-->
<pre><span id="lnum6" style="color: #606060;">   6:</span> {</pre>
<!--CRLF-->
<pre><span id="lnum7" style="color: #606060;">   7:</span>     pgd_t *pgd;</pre>
<!--CRLF-->
<pre><span id="lnum8" style="color: #606060;">   8:</span>     pud_t *pud;</pre>
<!--CRLF-->
<pre><span id="lnum9" style="color: #606060;">   9:</span>     pmd_t *pmd;</pre>
<!--CRLF-->
<pre><span id="lnum10" style="color: #606060;">  10:</span>     pte_t *pte;</pre>
<!--CRLF-->
<pre><span id="lnum11" style="color: #606060;">  11:</span>&nbsp; </pre>
<!--CRLF-->
<pre><span id="lnum12" style="color: #606060;">  12:</span>     __set_current_state(TASK_RUNNING);</pre>
<!--CRLF-->
<pre><span id="lnum13" style="color: #606060;">  13:</span>&nbsp; </pre>
<!--CRLF-->
<pre><span id="lnum14" style="color: #606060;">  14:</span>     count_vm_event(PGFAULT);</pre>
<!--CRLF-->
<pre><span id="lnum15" style="color: #606060;">  15:</span>     mem_cgroup_count_vm_event(mm, PGFAULT);</pre>
<!--CRLF-->
<pre><span id="lnum16" style="color: #606060;">  16:</span>&nbsp; </pre>
<!--CRLF-->
<pre><span id="lnum17" style="color: #606060;">  17:</span>     <span style="color: #008000;">/* do counter updates before entering really critical section. */</span></pre>
<!--CRLF-->
<pre><span id="lnum18" style="color: #606060;">  18:</span>     check_sync_rss_stat(current);</pre>
<!--CRLF-->
<pre><span id="lnum19" style="color: #606060;">  19:</span>&nbsp; </pre>
<!--CRLF-->
<pre><span id="lnum20" style="color: #606060;">  20:</span>     <span style="color: #0000ff;">if</span> (unlikely(is_vm_hugetlb_page(vma)))</pre>
<!--CRLF-->
<pre><span id="lnum21" style="color: #606060;">  21:</span>         <span style="color: #0000ff;">return</span> hugetlb_fault(mm, vma, address, flags);</pre>
<!--CRLF-->
<pre><span id="lnum22" style="color: #606060;">  22:</span>&nbsp; </pre>
<!--CRLF-->
<pre><span id="lnum23" style="color: #606060;">  23:</span> retry:</pre>
<!--CRLF-->
<pre><span id="lnum24" style="color: #606060;">  24:</span>     pgd = pgd_offset(mm, address);</pre>
<!--CRLF-->
<pre><span id="lnum25" style="color: #606060;">  25:</span>     pud = pud_alloc(mm, pgd, address);</pre>
<!--CRLF-->
<pre><span id="lnum26" style="color: #606060;">  26:</span>     <span style="color: #0000ff;">if</span> (!pud)</pre>
<!--CRLF-->
<pre><span id="lnum27" style="color: #606060;">  27:</span>         <span style="color: #0000ff;">return</span> VM_FAULT_OOM;</pre>
<!--CRLF-->
<pre><span id="lnum28" style="color: #606060;">  28:</span>     pmd = pmd_alloc(mm, pud, address);</pre>
<!--CRLF-->
<pre><span id="lnum29" style="color: #606060;">  29:</span>     <span style="color: #0000ff;">if</span> (!pmd)</pre>
<!--CRLF-->
<pre><span id="lnum30" style="color: #606060;">  30:</span>         <span style="color: #0000ff;">return</span> VM_FAULT_OOM;</pre>
<!--CRLF-->
<pre><span id="lnum31" style="color: #606060;">  31:</span>     <span style="color: #0000ff;">if</span> (pmd_none(*pmd) &amp;&amp; transparent_hugepage_enabled(vma)) {</pre>
<!--CRLF-->
<pre><span id="lnum32" style="color: #606060;">  32:</span>         <span style="color: #0000ff;">if</span> (!vma-&gt;vm_ops)</pre>
<!--CRLF-->
<pre><span id="lnum33" style="color: #606060;">  33:</span>             <span style="color: #0000ff;">return</span> do_huge_pmd_anonymous_page(mm, vma, address,</pre>
<!--CRLF-->
<pre><span id="lnum34" style="color: #606060;">  34:</span>                               pmd, flags);</pre>
<!--CRLF-->
<pre><span id="lnum35" style="color: #606060;">  35:</span>     } <span style="color: #0000ff;">else</span> {</pre>
<!--CRLF-->
<pre><span id="lnum36" style="color: #606060;">  36:</span>         pmd_t orig_pmd = *pmd;</pre>
<!--CRLF-->
<pre><span id="lnum37" style="color: #606060;">  37:</span>         <span style="color: #0000ff;">int</span> ret;</pre>
<!--CRLF-->
<pre><span id="lnum38" style="color: #606060;">  38:</span>&nbsp; </pre>
<!--CRLF-->
<pre><span id="lnum39" style="color: #606060;">  39:</span>         barrier();</pre>
<!--CRLF-->
<pre><span id="lnum40" style="color: #606060;">  40:</span>         <span style="color: #0000ff;">if</span> (pmd_trans_huge(orig_pmd)) {</pre>
<!--CRLF-->
<pre><span id="lnum41" style="color: #606060;">  41:</span>             <span style="color: #0000ff;">if</span> (flags &amp; FAULT_FLAG_WRITE &amp;&amp;</pre>
<!--CRLF-->
<pre><span id="lnum42" style="color: #606060;">  42:</span>                 !pmd_write(orig_pmd) &amp;&amp;</pre>
<!--CRLF-->
<pre><span id="lnum43" style="color: #606060;">  43:</span>                 !pmd_trans_splitting(orig_pmd)) {</pre>
<!--CRLF-->
<pre><span id="lnum44" style="color: #606060;">  44:</span>                 ret = do_huge_pmd_wp_page(mm, vma, address, pmd,</pre>
<!--CRLF-->
<pre><span id="lnum45" style="color: #606060;">  45:</span>                               orig_pmd);</pre>
<!--CRLF-->
<pre><span id="lnum46" style="color: #606060;">  46:</span>                 <span style="color: #008000;">/*</span></pre>
<!--CRLF-->
<pre><span id="lnum47" style="color: #606060;">  47:</span> <span style="color: #008000;">                 * If COW results in an oom, the huge pmd will</span></pre>
<!--CRLF-->
<pre><span id="lnum48" style="color: #606060;">  48:</span> <span style="color: #008000;">                 * have been split, so retry the fault on the</span></pre>
<!--CRLF-->
<pre><span id="lnum49" style="color: #606060;">  49:</span> <span style="color: #008000;">                 * pte for a smaller charge.</span></pre>
<!--CRLF-->
<pre><span id="lnum50" style="color: #606060;">  50:</span> <span style="color: #008000;">                 */</span></pre>
<!--CRLF-->
<pre><span id="lnum51" style="color: #606060;">  51:</span>                 <span style="color: #0000ff;">if</span> (unlikely(ret &amp; VM_FAULT_OOM))</pre>
<!--CRLF-->
<pre><span id="lnum52" style="color: #606060;">  52:</span>                     <span style="color: #0000ff;">goto</span> retry;</pre>
<!--CRLF-->
<pre><span id="lnum53" style="color: #606060;">  53:</span>                 <span style="color: #0000ff;">return</span> ret;</pre>
<!--CRLF-->
<pre><span id="lnum54" style="color: #606060;">  54:</span>             }</pre>
<!--CRLF-->
<pre><span id="lnum55" style="color: #606060;">  55:</span>             <span style="color: #0000ff;">return</span> 0;</pre>
<!--CRLF-->
<pre><span id="lnum56" style="color: #606060;">  56:</span>         }</pre>
<!--CRLF-->
<pre><span id="lnum57" style="color: #606060;">  57:</span>     }</pre>
<!--CRLF-->
<pre><span id="lnum58" style="color: #606060;">  58:</span>&nbsp; </pre>
<!--CRLF-->
<pre><span id="lnum59" style="color: #606060;">  59:</span>     <span style="color: #008000;">/*</span></pre>
<!--CRLF-->
<pre><span id="lnum60" style="color: #606060;">  60:</span> <span style="color: #008000;">     * Use __pte_alloc instead of pte_alloc_map, because we can't</span></pre>
<!--CRLF-->
<pre><span id="lnum61" style="color: #606060;">  61:</span> <span style="color: #008000;">     * run pte_offset_map on the pmd, if an huge pmd could</span></pre>
<!--CRLF-->
<pre><span id="lnum62" style="color: #606060;">  62:</span> <span style="color: #008000;">     * materialize from under us from a different thread.</span></pre>
<!--CRLF-->
<pre><span id="lnum63" style="color: #606060;">  63:</span> <span style="color: #008000;">     */</span></pre>
<!--CRLF-->
<pre><span id="lnum64" style="color: #606060;">  64:</span>     <span style="color: #0000ff;">if</span> (unlikely(pmd_none(*pmd)) &amp;&amp; __pte_alloc(mm, vma, pmd, address))</pre>
<!--CRLF-->
<pre><span id="lnum65" style="color: #606060;">  65:</span>         <span style="color: #0000ff;">return</span> VM_FAULT_OOM;</pre>
<!--CRLF-->
<pre><span id="lnum66" style="color: #606060;">  66:</span>     <span style="color: #008000;">/* if an huge pmd materialized from under us just retry later */</span></pre>
<!--CRLF-->
<pre><span id="lnum67" style="color: #606060;">  67:</span>     <span style="color: #0000ff;">if</span> (unlikely(pmd_trans_huge(*pmd)))</pre>
<!--CRLF-->
<pre><span id="lnum68" style="color: #606060;">  68:</span>         <span style="color: #0000ff;">return</span> 0;</pre>
<!--CRLF-->
<pre><span id="lnum69" style="color: #606060;">  69:</span>     <span style="color: #008000;">/*</span></pre>
<!--CRLF-->
<pre><span id="lnum70" style="color: #606060;">  70:</span> <span style="color: #008000;">     * A regular pmd is established and it can't morph into a huge pmd</span></pre>
<!--CRLF-->
<pre><span id="lnum71" style="color: #606060;">  71:</span> <span style="color: #008000;">     * from under us anymore at this point because we hold the mmap_sem</span></pre>
<!--CRLF-->
<pre><span id="lnum72" style="color: #606060;">  72:</span> <span style="color: #008000;">     * read mode and khugepaged takes it in write mode. So now it's</span></pre>
<!--CRLF-->
<pre><span id="lnum73" style="color: #606060;">  73:</span> <span style="color: #008000;">     * safe to run pte_offset_map().</span></pre>
<!--CRLF-->
<pre><span id="lnum74" style="color: #606060;">  74:</span> <span style="color: #008000;">     */</span></pre>
<!--CRLF-->
<pre><span id="lnum75" style="color: #606060;">  75:</span>     pte = pte_offset_map(pmd, address);</pre>
<!--CRLF-->
<pre><span id="lnum76" style="color: #606060;">  76:</span>&nbsp; </pre>
<!--CRLF-->
<pre><span id="lnum77" style="color: #606060;">  77:</span>     <span style="color: #0000ff;">return</span> handle_pte_fault(mm, vma, address, pte, pmd, flags);</pre>
<!--CRLF-->
<pre><span id="lnum78" style="color: #606060;">  78:</span> }</pre>
<!--CRLF--></div>
</div>
<p>&nbsp;</p>
<div id="codeSnippetWrapper" style="text-align: left; line-height: 12pt; background-color: #f4f4f4; margin: 20px 0px 10px; width: 97.5%; font-family: 'Courier New', courier, monospace; direction: ltr; max-height: 200px; font-size: 8pt; overflow: auto; cursor: text; border: silver 1px solid; padding: 4px;">
<div id="codeSnippet" style="text-align: left; line-height: 12pt; background-color: #f4f4f4; width: 100%; font-family: 'Courier New', courier, monospace; direction: ltr; color: black; font-size: 8pt; overflow: visible; border-style: none; padding: 0px;">
<pre><span id="lnum1" style="color: #606060;">   1:</span> <span style="color: #008000;">/*</span></pre>
<!--CRLF-->
<pre><span id="lnum2" style="color: #606060;">   2:</span> <span style="color: #008000;"> * These routines also need to handle stuff like marking pages dirty</span></pre>
<!--CRLF-->
<pre><span id="lnum3" style="color: #606060;">   3:</span> <span style="color: #008000;"> * and/or accessed for architectures that don't do it in hardware (most</span></pre>
<!--CRLF-->
<pre><span id="lnum4" style="color: #606060;">   4:</span> <span style="color: #008000;"> * RISC architectures).  The early dirtying is also good on the i386.</span></pre>
<!--CRLF-->
<pre><span id="lnum5" style="color: #606060;">   5:</span> <span style="color: #008000;"> *</span></pre>
<!--CRLF-->
<pre><span id="lnum6" style="color: #606060;">   6:</span> <span style="color: #008000;"> * There is also a hook called "update_mmu_cache()" that architectures</span></pre>
<!--CRLF-->
<pre><span id="lnum7" style="color: #606060;">   7:</span> <span style="color: #008000;"> * with external mmu caches can use to update those (ie the Sparc or</span></pre>
<!--CRLF-->
<pre><span id="lnum8" style="color: #606060;">   8:</span> <span style="color: #008000;"> * PowerPC hashed page tables that act as extended TLBs).</span></pre>
<!--CRLF-->
<pre><span id="lnum9" style="color: #606060;">   9:</span> <span style="color: #008000;"> *</span></pre>
<!--CRLF-->
<pre><span id="lnum10" style="color: #606060;">  10:</span> <span style="color: #008000;"> * We enter with non-exclusive mmap_sem (to exclude vma changes,</span></pre>
<!--CRLF-->
<pre><span id="lnum11" style="color: #606060;">  11:</span> <span style="color: #008000;"> * but allow concurrent faults), and pte mapped but not yet locked.</span></pre>
<!--CRLF-->
<pre><span id="lnum12" style="color: #606060;">  12:</span> <span style="color: #008000;"> * We return with mmap_sem still held, but pte unmapped and unlocked.</span></pre>
<!--CRLF-->
<pre><span id="lnum13" style="color: #606060;">  13:</span> <span style="color: #008000;"> */</span></pre>
<!--CRLF-->
<pre><span id="lnum14" style="color: #606060;">  14:</span> <span style="color: #0000ff;">int</span> handle_pte_fault(<span style="color: #0000ff;">struct</span> mm_struct *mm,</pre>
<!--CRLF-->
<pre><span id="lnum15" style="color: #606060;">  15:</span>              <span style="color: #0000ff;">struct</span> vm_area_struct *vma, <span style="color: #0000ff;">unsigned</span> <span style="color: #0000ff;">long</span> address,</pre>
<!--CRLF-->
<pre><span id="lnum16" style="color: #606060;">  16:</span>              pte_t *pte, pmd_t *pmd, <span style="color: #0000ff;">unsigned</span> <span style="color: #0000ff;">int</span> flags)</pre>
<!--CRLF-->
<pre><span id="lnum17" style="color: #606060;">  17:</span> {</pre>
<!--CRLF-->
<pre><span id="lnum18" style="color: #606060;">  18:</span>     pte_t entry;</pre>
<!--CRLF-->
<pre><span id="lnum19" style="color: #606060;">  19:</span>     spinlock_t *ptl;</pre>
<!--CRLF-->
<pre><span id="lnum20" style="color: #606060;">  20:</span>&nbsp; </pre>
<!--CRLF-->
<pre><span id="lnum21" style="color: #606060;">  21:</span>     entry = *pte;</pre>
<!--CRLF-->
<pre><span id="lnum22" style="color: #606060;">  22:</span>     <span style="color: #0000ff;">if</span> (!pte_present(entry)) {</pre>
<!--CRLF-->
<pre><span id="lnum23" style="color: #606060;">  23:</span>         <span style="color: #0000ff;">if</span> (pte_none(entry)) {</pre>
<!--CRLF-->
<pre><span id="lnum24" style="color: #606060;">  24:</span>             <span style="color: #0000ff;">if</span> (vma-&gt;vm_ops) {</pre>
<!--CRLF-->
<pre><span id="lnum25" style="color: #606060;">  25:</span>                 <span style="color: #0000ff;">if</span> (likely(vma-&gt;vm_ops-&gt;fault))</pre>
<!--CRLF-->
<pre><span id="lnum26" style="color: #606060;">  26:</span>                     <span style="color: #0000ff;">return</span> do_linear_fault(mm, vma, address,</pre>
<!--CRLF-->
<pre><span id="lnum27" style="color: #606060;">  27:</span>                         pte, pmd, flags, entry);</pre>
<!--CRLF-->
<pre><span id="lnum28" style="color: #606060;">  28:</span>             }</pre>
<!--CRLF-->
<pre><span id="lnum29" style="color: #606060;">  29:</span>             <span style="color: #0000ff;">return</span> do_anonymous_page(mm, vma, address,</pre>
<!--CRLF-->
<pre><span id="lnum30" style="color: #606060;">  30:</span>                          pte, pmd, flags);</pre>
<!--CRLF-->
<pre><span id="lnum31" style="color: #606060;">  31:</span>         }</pre>
<!--CRLF-->
<pre><span id="lnum32" style="color: #606060;">  32:</span>         <span style="color: #0000ff;">if</span> (pte_file(entry))</pre>
<!--CRLF-->
<pre><span id="lnum33" style="color: #606060;">  33:</span>             <span style="color: #0000ff;">return</span> do_nonlinear_fault(mm, vma, address,</pre>
<!--CRLF-->
<pre><span id="lnum34" style="color: #606060;">  34:</span>                     pte, pmd, flags, entry);</pre>
<!--CRLF-->
<pre><span id="lnum35" style="color: #606060;">  35:</span>         <span style="color: #0000ff;">return</span> do_swap_page(mm, vma, address,</pre>
<!--CRLF-->
<pre><span id="lnum36" style="color: #606060;">  36:</span>                     pte, pmd, flags, entry);</pre>
<!--CRLF-->
<pre><span id="lnum37" style="color: #606060;">  37:</span>     }</pre>
<!--CRLF-->
<pre><span id="lnum38" style="color: #606060;">  38:</span>&nbsp; </pre>
<!--CRLF-->
<pre><span id="lnum39" style="color: #606060;">  39:</span>     ptl = pte_lockptr(mm, pmd);</pre>
<!--CRLF-->
<pre><span id="lnum40" style="color: #606060;">  40:</span>     spin_lock(ptl);</pre>
<!--CRLF-->
<pre><span id="lnum41" style="color: #606060;">  41:</span>     <span style="color: #0000ff;">if</span> (unlikely(!pte_same(*pte, entry)))</pre>
<!--CRLF-->
<pre><span id="lnum42" style="color: #606060;">  42:</span>         <span style="color: #0000ff;">goto</span> unlock;</pre>
<!--CRLF-->
<pre><span id="lnum43" style="color: #606060;">  43:</span>     <span style="color: #0000ff;">if</span> (flags &amp; FAULT_FLAG_WRITE) {</pre>
<!--CRLF-->
<pre><span id="lnum44" style="color: #606060;">  44:</span>         <span style="color: #0000ff;">if</span> (!pte_write(entry))</pre>
<!--CRLF-->
<pre><span id="lnum45" style="color: #606060;">  45:</span>             <span style="color: #0000ff;">return</span> do_wp_page(mm, vma, address,</pre>
<!--CRLF-->
<pre><span id="lnum46" style="color: #606060;">  46:</span>                     pte, pmd, ptl, entry);</pre>
<!--CRLF-->
<pre><span id="lnum47" style="color: #606060;">  47:</span>         entry = pte_mkdirty(entry);</pre>
<!--CRLF-->
<pre><span id="lnum48" style="color: #606060;">  48:</span>     }</pre>
<!--CRLF-->
<pre><span id="lnum49" style="color: #606060;">  49:</span>     entry = pte_mkyoung(entry);</pre>
<!--CRLF-->
<pre><span id="lnum50" style="color: #606060;">  50:</span>     <span style="color: #0000ff;">if</span> (ptep_set_access_flags(vma, address, pte, entry, flags &amp; FAULT_FLAG_WRITE)) {</pre>
<!--CRLF-->
<pre><span id="lnum51" style="color: #606060;">  51:</span>         update_mmu_cache(vma, address, pte);</pre>
<!--CRLF-->
<pre><span id="lnum52" style="color: #606060;">  52:</span>     } <span style="color: #0000ff;">else</span> {</pre>
<!--CRLF-->
<pre><span id="lnum53" style="color: #606060;">  53:</span>         <span style="color: #008000;">/*</span></pre>
<!--CRLF-->
<pre><span id="lnum54" style="color: #606060;">  54:</span> <span style="color: #008000;">         * This is needed only for protection faults but the arch code</span></pre>
<!--CRLF-->
<pre><span id="lnum55" style="color: #606060;">  55:</span> <span style="color: #008000;">         * is not yet telling us if this is a protection fault or not.</span></pre>
<!--CRLF-->
<pre><span id="lnum56" style="color: #606060;">  56:</span> <span style="color: #008000;">         * This still avoids useless tlb flushes for .text page faults</span></pre>
<!--CRLF-->
<pre><span id="lnum57" style="color: #606060;">  57:</span> <span style="color: #008000;">         * with threads.</span></pre>
<!--CRLF-->
<pre><span id="lnum58" style="color: #606060;">  58:</span> <span style="color: #008000;">         */</span></pre>
<!--CRLF-->
<pre><span id="lnum59" style="color: #606060;">  59:</span>         <span style="color: #0000ff;">if</span> (flags &amp; FAULT_FLAG_WRITE)</pre>
<!--CRLF-->
<pre><span id="lnum60" style="color: #606060;">  60:</span>             flush_tlb_fix_spurious_fault(vma, address);</pre>
<!--CRLF-->
<pre><span id="lnum61" style="color: #606060;">  61:</span>     }</pre>
<!--CRLF-->
<pre><span id="lnum62" style="color: #606060;">  62:</span> unlock:</pre>
<!--CRLF-->
<pre><span id="lnum63" style="color: #606060;">  63:</span>     pte_unmap_unlock(pte, ptl);</pre>
<!--CRLF-->
<pre><span id="lnum64" style="color: #606060;">  64:</span>     <span style="color: #0000ff;">return</span> 0;</pre>
<!--CRLF-->
<pre><span id="lnum65" style="color: #606060;">  65:</span> }</pre>
<!--CRLF--></div>
</div>
<blockquote>
<p>entry = *pte;<br />if (!pte_present(entry)) {<br />&nbsp;&nbsp;&nbsp; if (pte_none(entry)) {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (vma-&gt;vm_ops) {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (likely(vma-&gt;vm_ops-&gt;fault))<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return <span style="color: #ff0000;">do_linear_fault</span>(mm, vma, address,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pte, pmd, flags, entry);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return <span style="color: #ff0000;">do_anonymous_page</span>(mm, vma, address,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pte, pmd, flags);<br />&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp; if (pte_file(entry))<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return <span style="color: #ff0000;">do_nonlinear_fault</span>(mm, vma, address,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pte, pmd, flags, entry);<br />&nbsp;&nbsp;&nbsp; return <span style="color: #ff0000;">do_swap_page</span>(mm, vma, address,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pte, pmd, flags, entry);<br />}</p>
</blockquote>
<p>如果页对应的是一个文件映射的话，就调用do_nonlinear_fault处理。（To Be Discussed!）</p>
<p>如果是按需调页的情况，就调用do_swap_page。</p>
<h3>Copy on Write写时复制</h3>
<blockquote>
<p>Modern Unix kernels, including Linux, follow a more efficient approach called Copy On Write(COW).<br />The idea is quite simple: instead of duplicating page frames, they are shared between the parent<br />and the child process. However, as long as they are shared, they cannot be modified. Whenever the<br />parent or the child process attempts to write into a shared page frame, an exception occurs. <span style="color: #9b00d3;">At this<br />point, the kernel duplicates the page into a new page frame that it marks as writable</span>. The original<br />page frame remains write-protected: when the other process tries to write into it, the kernel checks<br />whether the writing process is the only owner of the page frame; in such a case, <span style="color: #ff0000;">it makes the page<br />frame writable for the process.</span></p>
<p>&nbsp;</p>
<p><span style="color: #ff0000;">【对于内存的处理，基本上都是由exception handler来驱动的：</span></p>
<p><span style="color: #ff0000;">Page Fault: 动态地去准备好相应的页；</span></p>
<p><span style="color: #ff0000;">Copy-on-Write: 父子进程间共享内存页，页设置为read-only，如果尝试write，才会激发COW机制，才会创建另外的page】</span></p>
<p>&nbsp;</p>
<p><span style="color: #ff0000;">【其实Linux内核的思想，与面向对象的思想很相似，只不过内核是通过exception驱动的，在exception handler中，根据情况（通常是各个标志）去调用不同的实现。】</span></p>
<p><span style="color: #ff0000;">【在细节上，struct中的函数指针成员，与c++中的vtable很相似，可以用来实现polymorphism】</span></p>
<p>&nbsp;</p>
</blockquote>
<p>在创建子进程时，将父子进程的页指向同一页帧(struct page)，并将其设置为write-protected，即如果以该页帧进行写操作时，会触发异常。</p>
<p>异常被操作系统捕获后，如果此时该页仍然被多个进程共享，就复制该页，将复制后的页设置为write-enable，提供给请求写操作的进程。如果此时只有请求进程自己在使用该页，就直接将该页设置为write-enable，允许请求进程进行写操作。</p>
<p>&nbsp;</p>
<p>brk调整进程堆大小</p>
<div id="codeSnippetWrapper" style="text-align: left; line-height: 12pt; background-color: #f4f4f4; margin: 20px 0px 10px; width: 97.5%; font-family: 'Courier New', courier, monospace; direction: ltr; max-height: 200px; font-size: 8pt; overflow: auto; cursor: text; border: silver 1px solid; padding: 4px;">
<div id="codeSnippet" style="text-align: left; line-height: 12pt; background-color: #f4f4f4; width: 100%; font-family: 'Courier New', courier, monospace; direction: ltr; color: black; font-size: 8pt; overflow: visible; border-style: none; padding: 0px;">
<pre><span id="lnum1" style="color: #606060;">   1:</span> SYSCALL_DEFINE1(brk, <span style="color: #0000ff;">unsigned</span> <span style="color: #0000ff;">long</span>, brk)</pre>
<!--CRLF-->
<pre><span id="lnum2" style="color: #606060;">   2:</span> {</pre>
<!--CRLF-->
<pre><span id="lnum3" style="color: #606060;">   3:</span>     <span style="color: #0000ff;">unsigned</span> <span style="color: #0000ff;">long</span> rlim, retval;</pre>
<!--CRLF-->
<pre><span id="lnum4" style="color: #606060;">   4:</span>     <span style="color: #0000ff;">unsigned</span> <span style="color: #0000ff;">long</span> newbrk, oldbrk;</pre>
<!--CRLF-->
<pre><span id="lnum5" style="color: #606060;">   5:</span>     <span style="color: #0000ff;">struct</span> mm_struct *mm = current-&gt;mm;</pre>
<!--CRLF-->
<pre><span id="lnum6" style="color: #606060;">   6:</span>     <span style="color: #0000ff;">unsigned</span> <span style="color: #0000ff;">long</span> min_brk;</pre>
<!--CRLF-->
<pre><span id="lnum7" style="color: #606060;">   7:</span>&nbsp; </pre>
<!--CRLF-->
<pre><span id="lnum8" style="color: #606060;">   8:</span>     down_write(&amp;mm-&gt;mmap_sem);</pre>
<!--CRLF-->
<pre><span id="lnum9" style="color: #606060;">   9:</span>&nbsp; </pre>
<!--CRLF-->
<pre><span id="lnum10" style="color: #606060;">  10:</span> <span style="color: #cc6633;">#ifdef</span> CONFIG_COMPAT_BRK</pre>
<!--CRLF-->
<pre><span id="lnum11" style="color: #606060;">  11:</span>     <span style="color: #008000;">/*</span></pre>
<!--CRLF-->
<pre><span id="lnum12" style="color: #606060;">  12:</span> <span style="color: #008000;">     * CONFIG_COMPAT_BRK can still be overridden by setting</span></pre>
<!--CRLF-->
<pre><span id="lnum13" style="color: #606060;">  13:</span> <span style="color: #008000;">     * randomize_va_space to 2, which will still cause mm-&gt;start_brk</span></pre>
<!--CRLF-->
<pre><span id="lnum14" style="color: #606060;">  14:</span> <span style="color: #008000;">     * to be arbitrarily shifted</span></pre>
<!--CRLF-->
<pre><span id="lnum15" style="color: #606060;">  15:</span> <span style="color: #008000;">     */</span></pre>
<!--CRLF-->
<pre><span id="lnum16" style="color: #606060;">  16:</span>     <span style="color: #0000ff;">if</span> (current-&gt;brk_randomized)</pre>
<!--CRLF-->
<pre><span id="lnum17" style="color: #606060;">  17:</span>         min_brk = mm-&gt;start_brk;</pre>
<!--CRLF-->
<pre><span id="lnum18" style="color: #606060;">  18:</span>     <span style="color: #0000ff;">else</span></pre>
<!--CRLF-->
<pre><span id="lnum19" style="color: #606060;">  19:</span>         min_brk = mm-&gt;end_data;</pre>
<!--CRLF-->
<pre><span id="lnum20" style="color: #606060;">  20:</span> <span style="color: #cc6633;">#else</span></pre>
<!--CRLF-->
<pre><span id="lnum21" style="color: #606060;">  21:</span>     min_brk = mm-&gt;start_brk;</pre>
<!--CRLF-->
<pre><span id="lnum22" style="color: #606060;">  22:</span> <span style="color: #cc6633;">#endif</span></pre>
<!--CRLF-->
<pre><span id="lnum23" style="color: #606060;">  23:</span>     <span style="color: #0000ff;">if</span> (brk &lt; min_brk)</pre>
<!--CRLF-->
<pre><span id="lnum24" style="color: #606060;">  24:</span>         <span style="color: #0000ff;">goto</span> out;</pre>
<!--CRLF-->
<pre><span id="lnum25" style="color: #606060;">  25:</span>&nbsp; </pre>
<!--CRLF-->
<pre><span id="lnum26" style="color: #606060;">  26:</span>     <span style="color: #008000;">/*</span></pre>
<!--CRLF-->
<pre><span id="lnum27" style="color: #606060;">  27:</span> <span style="color: #008000;">     * Check against rlimit here. If this check is done later after the test</span></pre>
<!--CRLF-->
<pre><span id="lnum28" style="color: #606060;">  28:</span> <span style="color: #008000;">     * of oldbrk with newbrk then it can escape the test and let the data</span></pre>
<!--CRLF-->
<pre><span id="lnum29" style="color: #606060;">  29:</span> <span style="color: #008000;">     * segment grow beyond its set limit the in case where the limit is</span></pre>
<!--CRLF-->
<pre><span id="lnum30" style="color: #606060;">  30:</span> <span style="color: #008000;">     * not page aligned -Ram Gupta</span></pre>
<!--CRLF-->
<pre><span id="lnum31" style="color: #606060;">  31:</span> <span style="color: #008000;">     */</span></pre>
<!--CRLF-->
<pre><span id="lnum32" style="color: #606060;">  32:</span>     rlim = rlimit(RLIMIT_DATA);</pre>
<!--CRLF-->
<pre><span id="lnum33" style="color: #606060;">  33:</span>     <span style="color: #0000ff;">if</span> (rlim &lt; RLIM_INFINITY &amp;&amp; (brk - mm-&gt;start_brk) +</pre>
<!--CRLF-->
<pre><span id="lnum34" style="color: #606060;">  34:</span>             (mm-&gt;end_data - mm-&gt;start_data) &gt; rlim)</pre>
<!--CRLF-->
<pre><span id="lnum35" style="color: #606060;">  35:</span>         <span style="color: #0000ff;">goto</span> out;</pre>
<!--CRLF-->
<pre><span id="lnum36" style="color: #606060;">  36:</span>&nbsp; </pre>
<!--CRLF-->
<pre><span id="lnum37" style="color: #606060;">  37:</span>     newbrk = PAGE_ALIGN(brk);</pre>
<!--CRLF-->
<pre><span id="lnum38" style="color: #606060;">  38:</span>     oldbrk = PAGE_ALIGN(mm-&gt;brk);</pre>
<!--CRLF-->
<pre><span id="lnum39" style="color: #606060;">  39:</span>     <span style="color: #0000ff;">if</span> (oldbrk == newbrk)</pre>
<!--CRLF-->
<pre><span id="lnum40" style="color: #606060;">  40:</span>         <span style="color: #0000ff;">goto</span> set_brk;</pre>
<!--CRLF-->
<pre><span id="lnum41" style="color: #606060;">  41:</span>&nbsp; </pre>
<!--CRLF-->
<pre><span id="lnum42" style="color: #606060;">  42:</span>     <span style="color: #008000;">/* Always allow shrinking brk. */</span></pre>
<!--CRLF-->
<pre><span id="lnum43" style="color: #606060;">  43:</span>     <span style="color: #0000ff;">if</span> (brk &lt;= mm-&gt;brk) {</pre>
<!--CRLF-->
<pre><span id="lnum44" style="color: #606060;">  44:</span>         <span style="color: #0000ff;">if</span> (!do_munmap(mm, newbrk, oldbrk-newbrk))</pre>
<!--CRLF-->
<pre><span id="lnum45" style="color: #606060;">  45:</span>             <span style="color: #0000ff;">goto</span> set_brk;</pre>
<!--CRLF-->
<pre><span id="lnum46" style="color: #606060;">  46:</span>         <span style="color: #0000ff;">goto</span> out;</pre>
<!--CRLF-->
<pre><span id="lnum47" style="color: #606060;">  47:</span>     }</pre>
<!--CRLF-->
<pre><span id="lnum48" style="color: #606060;">  48:</span>&nbsp; </pre>
<!--CRLF-->
<pre><span id="lnum49" style="color: #606060;">  49:</span>     <span style="color: #008000;">/* Check against existing mmap mappings. */</span></pre>
<!--CRLF-->
<pre><span id="lnum50" style="color: #606060;">  50:</span>     <span style="color: #0000ff;">if</span> (find_vma_intersection(mm, oldbrk, newbrk+PAGE_SIZE))</pre>
<!--CRLF-->
<pre><span id="lnum51" style="color: #606060;">  51:</span>         <span style="color: #0000ff;">goto</span> out;</pre>
<!--CRLF-->
<pre><span id="lnum52" style="color: #606060;">  52:</span>&nbsp; </pre>
<!--CRLF-->
<pre><span id="lnum53" style="color: #606060;">  53:</span>     <span style="color: #008000;">/* Ok, looks good - let it rip. */</span></pre>
<!--CRLF-->
<pre><span id="lnum54" style="color: #606060;">  54:</span>     <span style="color: #0000ff;">if</span> (do_brk(oldbrk, newbrk-oldbrk) != oldbrk)</pre>
<!--CRLF-->
<pre><span id="lnum55" style="color: #606060;">  55:</span>         <span style="color: #0000ff;">goto</span> out;</pre>
<!--CRLF-->
<pre><span id="lnum56" style="color: #606060;">  56:</span> set_brk:</pre>
<!--CRLF-->
<pre><span id="lnum57" style="color: #606060;">  57:</span>     mm-&gt;brk = brk;</pre>
<!--CRLF-->
<pre><span id="lnum58" style="color: #606060;">  58:</span> out:</pre>
<!--CRLF-->
<pre><span id="lnum59" style="color: #606060;">  59:</span>     retval = mm-&gt;brk;</pre>
<!--CRLF-->
<pre><span id="lnum60" style="color: #606060;">  60:</span>     up_write(&amp;mm-&gt;mmap_sem);</pre>
<!--CRLF-->
<pre><span id="lnum61" style="color: #606060;">  61:</span>     <span style="color: #0000ff;">return</span> retval;</pre>
<!--CRLF-->
<pre><span id="lnum62" style="color: #606060;">  62:</span> }</pre>
<!--CRLF--></div>
</div></body>
</html>
