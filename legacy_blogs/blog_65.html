<html xmlns="http://www.w3.org/1999/xhtml" lang="zh-cn">
<head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"></head>
<title>Monod&#x5230;Algebraic System</title>
<body><p>Haskell里面的Monad很神秘，那么为什么会有Monad呢，它来源于Algebraic System理论。</p>
<p>参考：</p>
<p><a href="http://bbs.chinaunix.net/archiver/tid-1412911.html?page=1">http://bbs.chinaunix.net/archiver/tid-1412911.html?page=1</a></p>
<p><a href="http://en.wikibooks.org/wiki/Haskell/Category_theory">http://en.wikibooks.org/wiki/Haskell/Category_theory</a></p>
<p><a href="http://en.wikipedia.org/wiki/Monoid">http://en.wikipedia.org/wiki/Monoid</a></p>
<p><a href="http://en.wikipedia.org/wiki/Semigroup">http://en.wikipedia.org/wiki/Semigroup</a></p>
<p>&nbsp;</p>
<h1>Monoid</h1>
<blockquote>
<p>In&nbsp;<a title="Abstract algebra" href="http://en.wikipedia.org/wiki/Abstract_algebra">abstract algebra</a>, a branch of&nbsp;<a title="Mathematics" href="http://en.wikipedia.org/wiki/Mathematics">mathematics</a>, a&nbsp;<strong>monoid</strong>&nbsp;is an&nbsp;<a title="Algebraic structure" href="http://en.wikipedia.org/wiki/Algebraic_structure">algebraic structure</a>&nbsp;with a single&nbsp;<a class="mw-redirect" title="Associative" href="http://en.wikipedia.org/wiki/Associative">associative</a>&nbsp;<a title="Binary operation" href="http://en.wikipedia.org/wiki/Binary_operation">binary operation</a>&nbsp;and an&nbsp;<a title="Identity element" href="http://en.wikipedia.org/wiki/Identity_element">identity element</a>.</p>
</blockquote>
<p>幺半群：是只有一个可组合的二元操作符，以及一个幺元的代数结构（中文应该译为代数系统）。</p>
<p>这是一种最简单的代数系统。</p>
<p>&nbsp;</p>
<h1>Category</h1>
<p>category指一个简单的集合，它包含下面三个要素：</p>
<p>1. objects的组合</p>
<p>2. morphisms（态射）的组合，即从一个object映射到另外一个object的关系</p>
<p>3. morphisms的composition，即两个morphisms的结合</p>
<p>&nbsp;</p>
<p>在Haskell中，objects就是各种type， morphisms就是在各种type的object之间进行转化的function， 而composition就是.将两个function结合起来。</p>
<p>&nbsp;</p>
<h1>Functor</h1>
<p>functor就是将Cat A中的object，转换成Cat B中的object。</p>
<p>在Haskell中，对应Functor以及它的函数fmap。</p>
<p>&nbsp;</p>
<h3><span id="Translating_categorical_concepts_into_Haskell" class="mw-headline">Translating categorical concepts into Haskell<span class="mw-editsection"><span class="mw-editsection-bracket">[<a title="Edit section: Translating categorical concepts into Haskell" href="http://en.wikibooks.org/w/index.php?title=Haskell/Category_theory&amp;action=edit&amp;section=6">edit</a><span class="mw-editsection-bracket">]</span></span></span></span></h3>
<blockquote>
<p>Functors provide a good example of how category theory gets translated into Haskell. The key points to remember are that:</p>
</blockquote>
<ul>
<li>
<blockquote>We work in the category&nbsp;<strong>Hask</strong>&nbsp;and its subcategories.</blockquote>
</li>
<li>
<blockquote>Objects are types.</blockquote>
</li>
<li>
<blockquote>Morphisms are functions.</blockquote>
</li>
<li>
<blockquote>Things that take a type and return another type are type constructors.</blockquote>
</li>
<li>
<blockquote>Things that take a function and return another function are higher-order functions.</blockquote>
</li>
<li>
<blockquote>Typeclasses, along with the polymorphism they provide, make a nice way of capturing the fact that in category theory things are often defined over a number of objects at once.</blockquote>
</li>
</ul>
<p>将一个type转换成另外一个type的是type constructors；</p>
<p>将一个function转换成另外一个function的就高阶functions;</p>
<p>&nbsp;</p>
<h1>Monad</h1>
<p>Monad是一种特殊的Functor，它也是将一个Cat A转换成另一个Cat B，但是同时它提供了两在Cat A和Cat B之间进行object转换的morphisms: unit和join（就是return和(&gt;&gt;=)）</p>
<p>&nbsp;</p>
<p><img src="http://long123king.github.io/legacy_blogs/img/blog_65_231142007441848.png" alt="" /></p>
<div class="cnblogs_Highlighter">
<pre class="brush:python;gutter:true;">Prelude&gt; import Control.Monad
Prelude Control.Monad&gt; :t join
join :: Monad m =&gt; m (m a) -&gt; m a
Prelude Control.Monad&gt; :t return
return :: Monad m =&gt; a -&gt; m a
Prelude Control.Monad&gt; 
</pre>
</div>
<p>　　</p></body>
</html>
